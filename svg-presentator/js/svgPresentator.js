// Generated by CoffeeScript 1.6.3
(function() {
  var absolutePosition, centerObject, centerObjectAnimated, createTransformString, hasOverview, hiddenOpacity, hideStep, hideSteps, inAnimation, init, keyDownHandler, linearInterpolate, load, log, maxSlideNumber, next, overview, previous, registerClickables, root, scaleThatfitsInto, showSlide, showStep, showSteps, slideNumber, stepNumber, viewHeight, viewRotation, viewScale, viewWidth, viewX, viewY;

  viewX = 0;

  viewY = 0;

  viewScale = 1;

  viewRotation = 0;

  viewWidth = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName('body')[0].clientWidth;

  viewHeight = window.innerHeight || document.documentElement.clientHeight || document.getElementsByTagName('body')[0].clientHeight;

  slideNumber = 0;

  stepNumber = -1;

  inAnimation = false;

  hiddenOpacity = 0.2;

  maxSlideNumber = 0;

  hasOverview = false;

  overview = null;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  log = function(text) {
    return console.log(text);
  };

  absolutePosition = function(el) {
    found;
    var baseRect, boundingRect, found, height, left, offsetBase, top, width;
    left = 0;
    top = 0;
    width = 0;
    height = 0;
    offsetBase = document.createElement('div');
    offsetBase.style.cssText = 'position:absolute;left:0;top:0';
    document.body.appendChild(offsetBase);
    boundingRect = el.getBoundingClientRect();
    baseRect = offsetBase.getBoundingClientRect();
    found = true;
    left = boundingRect.left - baseRect.left;
    top = boundingRect.top - baseRect.top;
    width = boundingRect.right - boundingRect.left;
    height = boundingRect.bottom - boundingRect.top;
    return {
      found: found,
      left: left,
      top: top,
      width: width,
      height: height,
      right: left + width,
      bottom: top + height
    };
  };

  scaleThatfitsInto = function(boundaryWidth, boundaryHeight, objectWidth, objectHeight) {
    var boundaryRatio, objectRatio;
    boundaryRatio = boundaryHeight / boundaryWidth;
    objectRatio = objectHeight / objectWidth;
    if (boundaryRatio < objectRatio) {
      return boundaryHeight / objectHeight;
    } else {
      return boundaryWidth / objectWidth;
    }
  };

  createTransformString = function(x, y, scale, rotation, originX, originY) {
    if (scale == null) {
      scale = 1;
    }
    if (rotation == null) {
      rotation = 0;
    }
    if (originX == null) {
      originX = 0;
    }
    if (originY == null) {
      originY = 0;
    }
    return "t" + x + "," + y + "s" + scale + "," + scale + "," + originX + "," + originY + "r" + rotation + "," + originX + "," + originY;
  };

  linearInterpolate = function(from, to, step, numberOfSteps) {
    return from + ((to - from) * step / numberOfSteps);
  };

  centerObject = function(graph, object) {
    var bBox, rotation, scale, translationX, translationY;
    rotation = Snap.deg(Math.acos(object.transform().localMatrix.a));
    graph.transform(createTransformString(0, 0, 1, rotation));
    bBox = absolutePosition(object.node);
    log(bBox);
    scale = scaleThatfitsInto(viewWidth, viewHeight, bBox.width, bBox.height);
    translationX = (viewWidth - bBox.width * scale) / 2 - (bBox.left + window.scrollX) * scale;
    translationY = (viewHeight - bBox.height * scale) / 2 - (bBox.top + window.scrollY) * scale;
    viewX = translationX;
    viewY = translationY;
    viewScale = scale;
    viewRotation = rotation;
    return graph.transform(createTransformString(translationX, translationY, scale, rotation));
  };

  centerObjectAnimated = function(graph, object, time) {
    var bBox, rotation, scale, translationX, translationY;
    if (time == null) {
      time = 1000;
    }
    rotation = 0;
    graph.transform(createTransformString(0, 0, 1, rotation));
    bBox = absolutePosition(object.node);
    log(bBox);
    scale = scaleThatfitsInto(viewWidth, viewHeight, bBox.width, bBox.height);
    translationX = (viewWidth - bBox.width * scale) / 2 - (bBox.left + window.scrollX) * scale;
    translationY = (viewHeight - bBox.height * scale) / 2 - (bBox.top + window.scrollY) * scale;
    inAnimation = true;
    return Snap.animate(1, 1000, function(l) {
      var rotationInterpolation, scaleInterpolation, string, xInterpolation, yInterpolation;
      xInterpolation = linearInterpolate(viewX, translationX, l, 1000);
      yInterpolation = linearInterpolate(viewY, translationY, l, 1000);
      scaleInterpolation = linearInterpolate(viewScale, scale, l, 1000);
      rotationInterpolation = linearInterpolate(viewRotation, rotation, l, 1000);
      string = createTransformString(xInterpolation, yInterpolation, scaleInterpolation, rotationInterpolation);
      return graph.attr({
        transform: string
      });
    }, time, mina.easeinout, function() {
      viewX = translationX;
      viewY = translationY;
      viewScale = scale;
      viewRotation = rotation;
      return inAnimation = false;
    });
  };

  showSlide = function(graph, slide) {
    log(1);
    return centerObjectAnimated(graph, slide, 500);
  };

  showStep = function(step) {
    return step.attr({
      "fill-opacity": step.attr("original-fill-opacity"),
      "stroke-opacity": step.attr("original-stroke-opacity")
    });
  };

  hideStep = function(step) {
    return step.attr({
      "fill-opacity": hiddenOpacity,
      "stroke-opacity": hiddenOpacity
    });
  };

  hideSteps = function(graph) {
    var steps;
    steps = graph.selectAll('.step');
    return steps.forEach(function(step) {
      var originalFillOpacity, originalStrokeOpacity;
      originalFillOpacity = step.attr("fill-opacity");
      originalStrokeOpacity = step.attr("stroke-opacity");
      return step.attr({
        "fill-opacity": hiddenOpacity,
        "stroke-opacity": hiddenOpacity,
        "original-fill-opacity": originalFillOpacity,
        "original-stroke-opacity": originalStrokeOpacity
      });
    });
  };

  showSteps = function(graph) {
    var steps;
    steps = graph.selectAll('.step');
    return steps.forEach(showStep);
  };

  next = function(graph) {
    var slide, steps;
    slide = graph.select('.slide[slideNumber="' + slideNumber + '"]');
    steps = slide.selectAll('.step');
    stepNumber++;
    if (stepNumber >= steps.length) {
      stepNumber = -1;
      slideNumber++;
      if (slideNumber === maxSlideNumber + 1) {
        slideNumber = 0;
        hideSteps(graph);
      }
      return showSlide(graph, graph.select('.slide[slideNumber="' + slideNumber + '"]'));
    } else {
      return showStep(slide.select('.step[stepNumber="' + stepNumber + '"'));
    }
  };

  previous = function(graph) {
    var slide, steps;
    slide = graph.select('.slide[slideNumber="' + slideNumber + '"]');
    steps = slide.selectAll('.step');
    if (stepNumber < 0) {
      slideNumber--;
      if (slideNumber === -1) {
        slideNumber = maxSlideNumber;
        showSteps(graph);
      }
      slide = graph.select('.slide[slideNumber="' + slideNumber + '"]');
      steps = slide.selectAll('.step');
      stepNumber = steps.length - 1;
      return showSlide(graph, slide);
    } else {
      hideStep(slide.select('.step[stepNumber="' + stepNumber + '"]'));
      return stepNumber--;
    }
  };

  keyDownHandler = function(e, graph) {
    var keycode;
    e = e || window.event;
    keycode = e.keyCode;
    if (inAnimation) {
      return;
    }
    if (keycode === 37) {
      return previous(graph);
    } else if (keycode === 38) {
      if (hasOverview) {
        return showSlide(graph, overview);
      }
    } else if (keycode === 39) {
      return next(graph);
    } else if (keycode === 40) {
      if (hasOverview) {
        return showSlide(graph, graph.select('.slide[slideNumber="' + slideNumber + '"'));
      }
    }
  };

  registerClickables = function(graph) {
    var clickables;
    clickables = graph.selectAll('.clickable');
    return clickables.forEach(function(clickable) {
      return clickable.node.onclick = function(e) {
        return showSlide(graph, graph.select('#' + this.id));
      };
    });
  };

  init = function(f) {
    var graph, slides, snap, startSlide, top;
    snap = Snap();
    graph = f.select('g');
    top = snap.g();
    slides = graph.selectAll('.slide');
    startSlide = graph.select('.slide[slideNumber="' + slideNumber + '"');
    overview = graph.select('.overview');
    hasOverview = overview != null;
    maxSlideNumber = slides.length - 1;
    snap.attr({
      viewBox: [0, 0, viewWidth, viewHeight]
    });
    hideSteps(graph);
    top.add(graph);
    centerObject(graph, startSlide);
    registerClickables(graph);
    return window.onkeydown = function(e) {
      return keyDownHandler(e, graph);
    };
  };

  load = function(file) {
    return Snap.load(file, init);
  };

  root.load = load;

}).call(this);
