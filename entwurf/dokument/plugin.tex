\section{Package plugin}{
\label{plugin}\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Interfaces}}
\entityintro{Constraint}{plugin.Constraint}{}
\entityintro{Exporter}{plugin.Exporter}{The exporter interface is implemented to export a graph from it's internal representation into a specific file.}
\entityintro{FilterSet}{plugin.FilterSet}{A FilterSet is used to collect all available filters for a specific Graph from a workspace.}
\entityintro{Importer}{plugin.Importer}{The importer interface is implemented when writting a class that can import files.}
\entityintro{LayoutAlgorithm}{plugin.LayoutAlgorithm}{An implementations of LayoutAlgorithm takes a graph.}
\entityintro{LayoutRegister}{plugin.LayoutRegister}{Stores a collection of layouts.}
\entityintro{Plugin}{plugin.Plugin}{This is the main entry point for plugins.}
\entityintro{Workspace}{plugin.Workspace}{A workspace contains a set of default actions and options for displaying a specific domain of graphs.}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{EdgeFilter}{plugin.EdgeFilter}{This class represents a filter for edges.}
\entityintro{EntryPointOption}{plugin.EntryPointOption}{An entry point option is an abstract superclass for all entry points, where the user can choose one of multiple entry points.}
\entityintro{LayoutOption}{plugin.LayoutOption}{An option for a layout of a specific graph.}
\entityintro{PluginManager}{plugin.PluginManager}{The plugin manager manages the access of the main application to the plugins.}
\entityintro{VertexFilter}{plugin.VertexFilter}{This Class represents a filter for vertex types.}
\entityintro{WorkspaceOption}{plugin.WorkspaceOption}{This is an option for a}
\vskip .1in
\vskip .1in
\subsection{\label{plugin.Constraint}\index{Constraint@\textit{ Constraint}}Interface Constraint}{
\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Constraint
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.Exporter}\index{Exporter@\textit{ Exporter}}Interface Exporter}{
\vskip .1in 
The exporter interface is implemented to export a graph from it's internal representation into a specific file. For every graph structure given as SerializedGraph/SerializedVertex/SerializedEdge interfaces the implementing class translates it into a FileOutputStream for the given file type, by \texttt{\small getSupportedFileEnding}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Exporter
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{exportGraph(SerializedGraph, FileOutputStream)}
{\bf  exportGraph}\\
\begin{lstlisting}[frame=none]
void exportGraph(graphmodel.SerializedGraph graph,java.io.FileOutputStream filestream)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This method writes an \texttt{\small SerializedGraph}{\small 
\refdefined{graphmodel.SerializedGraph}} into an FileOutputStream. The \texttt{\small SerializedGraph}{\small 
\refdefined{graphmodel.SerializedGraph}} enables us to read all attributes as Strings. To write the contained Information into the filestream is the task of this method
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- serializedGraph that contains the information to write to a file}
   \item{
\texttt{filestream} -- to write the information into}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the name of this importer.
}
\item{{\bf  Returns} -- 
name of this exporter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSupportedFileEnding()}
{\bf  getSupportedFileEnding}\\
\begin{lstlisting}[frame=none]
java.lang.String getSupportedFileEnding()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets all filetypes which this exporter can parse.
}
\item{{\bf  Returns} -- 
the supported file ending. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.FilterSet}\index{FilterSet@\textit{ FilterSet}}Interface FilterSet}{
\vskip .1in 
A FilterSet is used to collect all available filters for a specific Graph from a workspace. Just these filters will be displayed to the user for a specific graph.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface FilterSet
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEdgeFilter()}
{\bf  getEdgeFilter}\\
\begin{lstlisting}[frame=none]
java.util.List getEdgeFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a List of all available \texttt{\small EdgeFilter}{\small 
\refdefined{plugin.EdgeFilter}}
}
\item{{\bf  Returns} -- 
the list of EdgeFilters 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the name of this FilterSet.
}
\item{{\bf  Returns} -- 
name of this FilterSet 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexfilter()}
{\bf  getVertexfilter}\\
\begin{lstlisting}[frame=none]
java.util.List getVertexfilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a \texttt{\small List}{\small 
\refdefined{java.util.List}} of all available \texttt{\small VertexFilter}{\small 
\refdefined{plugin.VertexFilter}}.
}
\item{{\bf  Returns} -- 
the list of VertexFilters 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.Importer}\index{Importer@\textit{ Importer}}Interface Importer}{
\vskip .1in 
The importer interface is implemented when writting a class that can import files. This will enable Plugins that import specific files to be build. The main task of a class implementing this interface is to parse a FileInputStream into the Interface of an AbstractGraphModelBuilder. The AbstractGraphModelBuilder will then build the representation.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Importer
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the name of this importer.
}
\item{{\bf  Returns} -- 
name of this importer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSupportedFileEndings()}
{\bf  getSupportedFileEndings}\\
\begin{lstlisting}[frame=none]
java.lang.String getSupportedFileEndings()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the filetype which this importer can parse.
}
\item{{\bf  Returns} -- 
the supported file ending. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{importGraph(IGraphModelBuilder, FileInputStream)}
{\bf  importGraph}\\
\begin{lstlisting}[frame=none]
void importGraph(graphmodel.IGraphModelBuilder builder,java.io.FileInputStream filestream)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This method parses an FileInputStream into an AbstractGraphModelBuilder. It has to ensure that all information is transfered to a correct graphmodelbuilder.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{builder} -- that the values are parsed into}
   \item{
\texttt{filestream} -- from which the values are parsed}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.LayoutAlgorithm}\index{LayoutAlgorithm@\textit{ LayoutAlgorithm}}Interface LayoutAlgorithm}{
\vskip .1in 
An implementations of LayoutAlgorithm takes a graph. It assigns all vertices absolute coordinates and assigns all edges coordinates, they have to pass through. LayoutAlgorithms can be registered with a \texttt{\small LayoutOption}{\small 
\refdefined{plugin.LayoutOption}} at a \texttt{\small LayoutRegister}{\small 
\refdefined{plugin.LayoutRegister}}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface LayoutAlgorithm
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getSettings()}
{\bf  getSettings}\\
\begin{lstlisting}[frame=none]
parameter.Settings getSettings()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the set of parameters for this instance of the algorithm.
}
\item{{\bf  Returns} -- 
the set of parameters 
}%end item
\end{itemize}
}%end item
\item{ 
\index{layout(G)}
{\bf  layout}\\
\begin{lstlisting}[frame=none]
void layout(graphmodel.Graph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Layout the specified Graph.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the graph to layout}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.LayoutRegister}\index{LayoutRegister@\textit{ LayoutRegister}}Interface LayoutRegister}{
\vskip .1in 
Stores a collection of layouts. This\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface LayoutRegister
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addLayoutOption(E)}
{\bf  addLayoutOption}\\
\begin{lstlisting}[frame=none]
void addLayoutOption(LayoutOption option)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLayoutOptions()}
{\bf  getLayoutOptions}\\
\begin{lstlisting}[frame=none]
java.util.List getLayoutOptions()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.Plugin}\index{Plugin@\textit{ Plugin}}Interface Plugin}{
\vskip .1in 
This is the main entry point for plugins. Plugins have to register their content extensions via this interface. The plugin manager will load classes implementing this interface with a service loader, when they are correctly described in the plugins META-INF.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Plugin
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEdgeFilter()}
{\bf  getEdgeFilter}\\
\begin{lstlisting}[frame=none]
java.util.List getEdgeFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all by the plugin provided \texttt{\small EdgeFilter}{\small 
\refdefined{plugin.EdgeFilter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
the list of provided edge filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getExporter()}
{\bf  getExporter}\\
\begin{lstlisting}[frame=none]
java.util.List getExporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all by the plugin provided \texttt{\small Exporter}{\small 
\refdefined{plugin.Exporter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
a list of provided exporter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getImporter()}
{\bf  getImporter}\\
\begin{lstlisting}[frame=none]
java.util.List getImporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all by the plugin provided \texttt{\small Importer}{\small 
\refdefined{plugin.Importer}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
a list of provided importer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the name of the plugin. Uniqueness can't be assumed.
}
\item{{\bf  Returns} -- 
the name of the plugin 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexFilter()}
{\bf  getVertexFilter}\\
\begin{lstlisting}[frame=none]
java.util.List getVertexFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all by the plugin provided \texttt{\small VertexFilter}{\small 
\refdefined{plugin.VertexFilter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
the list of provided vertex filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getWorkspaceOptions()}
{\bf  getWorkspaceOptions}\\
\begin{lstlisting}[frame=none]
java.util.List getWorkspaceOptions()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all provided by the plugin \texttt{\small WorkspaceOption}{\small 
\refdefined{plugin.WorkspaceOption}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
The list of provided workspace options 
}%end item
\end{itemize}
}%end item
\item{ 
\index{load()}
{\bf  load}\\
\begin{lstlisting}[frame=none]
void load()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Called after all plugins have been constructed. "Inter-Plugin" communication, like registering of layouts for graphs in other plugins should be executed in here.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.Workspace}\index{Workspace@\textit{ Workspace}}Interface Workspace}{
\vskip .1in 
A workspace contains a set of default actions and options for displaying a specific domain of graphs. The workspace manages the graphs instantiation through providing an \texttt{\small IGraphModelBuilder}{\small 
\refdefined{graphmodel.IGraphModelBuilder}}. He also provides a list of layout options for graphs in his model.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Workspace
\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getGraphModel()}
{\bf  getGraphModel}\\
\begin{lstlisting}[frame=none]
graphmodel.GraphModel getGraphModel()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the \texttt{\small GraphModel}{\small 
\refdefined{graphmodel.GraphModel}} stored in the workspace.
}
\item{{\bf  Returns} -- 
the graph model 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getGraphModelBuilder()}
{\bf  getGraphModelBuilder}\\
\begin{lstlisting}[frame=none]
graphmodel.IGraphModelBuilder getGraphModelBuilder()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a builder to build a graph model in this workspace.
}
\item{{\bf  Returns} -- 
the builder 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSettings()}
{\bf  getSettings}\\
\begin{lstlisting}[frame=none]
parameter.Settings getSettings()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a set of parameters to initialize this workspace. When the settings have been adjusted, the client has to call \texttt{\small initialize()}. To initialize the workspace with the settings.
}
\item{{\bf  Returns} -- 
the settings 
}%end item
\end{itemize}
}%end item
\item{ 
\index{initialize()}
{\bf  initialize}\\
\begin{lstlisting}[frame=none]
void initialize()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Initializes this workspace with the settings if they have not been adjusted. If the settings have not been adjusted, default values will be used.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.EdgeFilter}\index{EdgeFilter}Class EdgeFilter}{
\vskip .1in 
This class represents a filter for edges. To check if an edge passes through this filter, the client can specify it in \texttt{\small matches(Edge edge)}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public abstract class EdgeFilter
 extends java.lang.Object\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EdgeFilter()}
{\bf  EdgeFilter}\\
\begin{lstlisting}[frame=none]
public EdgeFilter()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the name of the filter.
}
\item{{\bf  Returns} -- 
the name of the filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{matches(Edge)}
{\bf  matches}\\
\begin{lstlisting}[frame=none]
public abstract boolean matches(graphmodel.Edge toMatch)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This method checks if an edge matches this Filter. It will compare specified parameters of the edge with the defined parameters of this filter.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{toMatch} -- the edge which should be checked}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the edge matches this Filter, otherwise false 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setName(String)}
{\bf  setName}\\
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the name of the filter.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{name} -- the name of the filter}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.EntryPointOption}\index{EntryPointOption}Class EntryPointOption}{
\vskip .1in 
An entry point option is an abstract superclass for all entry points, where the user can choose one of multiple entry points. Entry point options should allow a categorical overview for the entry point, to enable the client to differentiate the option from other options. Additionally a method for should be provided which can be executed when the client wants to select an option.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public abstract class EntryPointOption
 extends java.lang.Object\end{lstlisting}
\subsubsection{All known subclasses}{WorkspaceOption\small{\refdefined{plugin.WorkspaceOption}}, LayoutOption\small{\refdefined{plugin.LayoutOption}}}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EntryPointOption()}
{\bf  EntryPointOption}\\
\begin{lstlisting}[frame=none]
public EntryPointOption()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getID()}
{\bf  getID}\\
\begin{lstlisting}[frame=none]
public java.lang.String getID()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

The id of an entry point should be an acronym of it's name.
}
\item{{\bf  Returns} -- 
the id 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the name of the entry point option. This name can be displayed when displaying multiple options
}
\item{{\bf  Returns} -- 
the name of the entry point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setID(String)}
{\bf  setID}\\
\begin{lstlisting}[frame=none]
protected void setID(java.lang.String id)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the id of the entry point. The id should be an acronym of the name.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{id} -- the id of the entry point.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setName(String)}
{\bf  setName}\\
\begin{lstlisting}[frame=none]
protected void setName(java.lang.String name)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the name of the entry point
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{name} -- the name of the entry point}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.LayoutOption}\index{LayoutOption}Class LayoutOption}{
\vskip .1in 
An option for a layout of a specific graph. Workspaces can return these for a specific graph. The client can then decide between one ore more LayoutOptions When selected the layout will be applied to the graph.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public abstract class LayoutOption
 extends plugin.EntryPointOption implements java.lang.Cloneable\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{LayoutOption()}
{\bf  LayoutOption}\\
\begin{lstlisting}[frame=none]
public LayoutOption()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{applyLayout()}
{\bf  applyLayout}\\
\begin{lstlisting}[frame=none]
public abstract void applyLayout()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This should execute the layout on the graph, which should be specified on construction, or in beforehand. The settings, which are accessible over \texttt{\small getSettings()} will be used to instantiate the LayoutAlgorithm.
}
\end{itemize}
}%end item
\item{ 
\index{chooseLayout()}
{\bf  chooseLayout}\\
\begin{lstlisting}[frame=none]
public abstract void chooseLayout()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Called when this layout option is chosen. This allows the layout option to prepare the actual LayoutAlgorithm.
}
\end{itemize}
}%end item
\item{ 
\index{getSettings()}
{\bf  getSettings}\\
\begin{lstlisting}[frame=none]
public abstract parameter.Settings getSettings()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the set of parameters for an algorithm of this option. \texttt{\small choose()} has to be called up front.
}
\item{{\bf  Returns} -- 
the set of parameters 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.PluginManager}\index{PluginManager}Class PluginManager}{
\vskip .1in 
The plugin manager manages the access of the main application to the plugins. It loads all plugins at the start of the runtime. When the client needs some service implemented by plugins, it can get a list of all available options.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class PluginManager
 extends java.lang.Object\end{lstlisting}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEdgeFilter()}
{\bf  getEdgeFilter}\\
\begin{lstlisting}[frame=none]
public java.util.List getEdgeFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a list of all edge filter provided by plugins.
}
\item{{\bf  Returns} -- 
a list of all edge filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getExporter()}
{\bf  getExporter}\\
\begin{lstlisting}[frame=none]
public java.util.List getExporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the \texttt{\small Exporter}{\small 
\refdefined{plugin.Exporter}} provided by all plugins.
}
\item{{\bf  Returns} -- 
a list of provided exporter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getImporter()}
{\bf  getImporter}\\
\begin{lstlisting}[frame=none]
public java.util.List getImporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the \texttt{\small Importer}{\small 
\refdefined{plugin.Importer}} provided by all plugins.
}
\item{{\bf  Returns} -- 
a list of provided importer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPluginManager()}
{\bf  getPluginManager}\\
\begin{lstlisting}[frame=none]
public static PluginManager getPluginManager()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the singleton instance of the plugin manager.
}
\item{{\bf  Returns} -- 
the plugin manager 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPlugins()}
{\bf  getPlugins}\\
\begin{lstlisting}[frame=none]
public java.util.List getPlugins()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a list of all plugins loaded by the ServiceLoader.
}
\item{{\bf  Returns} -- 
all loaded plugins 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexFilter()}
{\bf  getVertexFilter}\\
\begin{lstlisting}[frame=none]
public java.util.List getVertexFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all vertex filter provided by plugins.
}
\item{{\bf  Returns} -- 
a list of all vertex filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getWorkspaceOptions()}
{\bf  getWorkspaceOptions}\\
\begin{lstlisting}[frame=none]
public java.util.List getWorkspaceOptions()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns all \texttt{\small WorkspaceOption}{\small 
\refdefined{plugin.WorkspaceOption}}s provided by plugins.
}
\item{{\bf  Returns} -- 
a list of all workspace options 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.VertexFilter}\index{VertexFilter}Class VertexFilter}{
\vskip .1in 
This Class represents a filter for vertex types. The type of the vertex can be specified through different parameters.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class VertexFilter
 extends java.lang.Object\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{VertexFilter()}
{\bf  VertexFilter}\\
\begin{lstlisting}[frame=none]
public VertexFilter()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Getter of name
}
\end{itemize}
}%end item
\item{ 
\index{matches(Vertex)}
{\bf  matches}\\
\begin{lstlisting}[frame=none]
public boolean matches(graphmodel.Vertex toMatch)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This method checks if an vertex matches this Filter. It will compare specified parameters of the vertex with the defined parameters of this filter.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{toMatch} -- the vertex which should be checked}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the edge matches this Filter, otherwise false 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setName(String)}
{\bf  setName}\\
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Setter of name
}
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{plugin.WorkspaceOption}\index{WorkspaceOption}Class WorkspaceOption}{
\vskip .1in 
This is an option for a\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public abstract class WorkspaceOption
 extends plugin.EntryPointOption\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{WorkspaceOption()}
{\bf  WorkspaceOption}\\
\begin{lstlisting}[frame=none]
public WorkspaceOption()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getInstance()}
{\bf  getInstance}\\
\begin{lstlisting}[frame=none]
public abstract Workspace getInstance()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates an instance of the workspace with the earlier adjusted Settings
}
\item{{\bf  Returns} -- 
a workspace 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSettings()}
{\bf  getSettings}\\
\begin{lstlisting}[frame=none]
public abstract parameter.Settings getSettings()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a set of parameters to initialize a workspace for this. When the settings have been adjusted, the client has to call \texttt{\small getInstance()}, to get an instance of the workspace with the settings.
}
\item{{\bf  Returns} -- 
the settings 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\printindex
