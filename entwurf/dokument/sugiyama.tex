\section{Package sugiyama}{
\label{sugiyama}\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Interfaces}}
\entityintro{ICrossMinimizer}{sugiyama.ICrossMinimizer}{This interface represents a class that takes a Sugiyama Graph and rearranges its vertices on each layer to minimize the amount of edge crossings.}
\entityintro{ICrossMinimizerGraph}{sugiyama.ICrossMinimizerGraph}{A LayeredGraph which additionally defines functions that can be used to minimize the crossings in the sugiyama-layout.}
\entityintro{ICycleRemover}{sugiyama.ICycleRemover}{This interfaces represents a class that generates a DAG(Directed Acyclic Graph) from a \texttt{\small DirectedGraph}{\small 
\refdefined{graphmodel.DirectedGraph}}.}
\entityintro{ICycleRemoverGraph}{sugiyama.ICycleRemoverGraph}{A DirectedGraph which additionally defines functions to remove cycles in the graph.}
\entityintro{IEdgeDrawer}{sugiyama.IEdgeDrawer}{This interface represents a class that takes a directed graph, as a SugiyamaClass.}
\entityintro{IEdgeDrawerGraph}{sugiyama.IEdgeDrawerGraph}{A LayeredGraph which additionally defines functions draw the edges in the sugiyama-layout.}
\entityintro{ILayerAssigner}{sugiyama.ILayerAssigner}{This interface represents a class that takes a directed graph and assigns every vertex in it a layer.}
\entityintro{ILayerAssignerGraph}{sugiyama.ILayerAssignerGraph}{A LayeredGraph which additionally defines functions to assign layers in the sugiyama-layout.}
\entityintro{IVertexPositioner}{sugiyama.IVertexPositioner}{This interface represents a class that takes a directed graph and position its vertices in order to look more clearly.}
\entityintro{IVertexPositionerGraph}{sugiyama.IVertexPositionerGraph}{A LayeredGraph which additionally defines functions to position vertices in the sugiyama-layout.}
\entityintro{LayeredLayoutAlgorithm}{sugiyama.LayeredLayoutAlgorithm}{A layout algorithm which is able to apply Layouts while keeping the notion of layers in addition to layout regular graphs.}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{AbsoluteLayerConstraint}{sugiyama.AbsoluteLayerConstraint}{A absolute constraint, regarding layer assignment, for one set of vertices.}
\entityintro{CrossMinimizer}{sugiyama.CrossMinimizer}{This class takes a Sugiyama Graph and rearranges its vertices on each layer to minimize the amount of edge crossings.}
\entityintro{CycleRemover}{sugiyama.CycleRemover}{This class takes a directed Graph G = (V, E) and removes a set of edges E\_\ so that the resulting Graph G' = (V, E\textbackslash E\_) is a DAG(Directed Acyclic Graph).}
\entityintro{EdgeDrawer}{sugiyama.EdgeDrawer}{This class takes a directed graph, as a SugiyamaClass.}
\entityintro{LayerAssigner}{sugiyama.LayerAssigner}{This class takes a directed graph and assigns every vertex in it a layer.}
\entityintro{RelativeLayerConstraint}{sugiyama.RelativeLayerConstraint}{A relative constraint, regarding layer assignment, between to sets of vertices.}
\entityintro{SugiyamaGraph}{sugiyama.SugiyamaGraph}{The SugiyamaGraph is a wrapper for a directed graph to enable easy and fast accessibility of attributes and constructs needed during the computation of the hierarchical layout of a directed graph.}
\entityintro{SugiyamaGraph.DummyVertex}{sugiyama.SugiyamaGraph.DummyVertex}{A supplement vertex which is part of a \texttt{\small SugiyamaGraph.SupplementPath}{\small 
\refdefined{sugiyama.SugiyamaGraph.SupplementPath}}.}
\entityintro{SugiyamaGraph.SugiyamaEdge}{sugiyama.SugiyamaGraph.SugiyamaEdge}{A wrapper class for directed edges to implement additional functionality to apply the sugiyama layout to the SugiyamaGraph containing them.}
\entityintro{SugiyamaGraph.SugiyamaVertex}{sugiyama.SugiyamaGraph.SugiyamaVertex}{A wrapper class for vertices used in the sugiyama framework.}
\entityintro{SugiyamaGraph.SupplementEdge}{sugiyama.SugiyamaGraph.SupplementEdge}{A supplement edge which is part of a \texttt{\small SugiyamaGraph.SupplementPath}{\small 
\refdefined{sugiyama.SugiyamaGraph.SupplementPath}}.}
\entityintro{SugiyamaGraph.SupplementPath}{sugiyama.SugiyamaGraph.SupplementPath}{A supplement path for connecting vertices, which are more than one layer apart.}
\entityintro{SugiyamaLayoutAlgorithm}{sugiyama.SugiyamaLayoutAlgorithm}{This class supports a customizable implementation of the Sugiyama-framework.}
\entityintro{SugiyamaPlugin}{sugiyama.SugiyamaPlugin}{A plugin for GAns that supplies a layout algorithm based on the Sugiyama-framework.}
\entityintro{VertexPositioner}{sugiyama.VertexPositioner}{This class takes a directed graph and position its vertices in order to look more clearly.}
\vskip .1in
\vskip .1in
\subsection{\label{sugiyama.ICrossMinimizer}\index{ICrossMinimizer@\textit{ ICrossMinimizer}}Interface ICrossMinimizer}{
\vskip .1in 
This interface represents a class that takes a Sugiyama Graph and rearranges its vertices on each layer to minimize the amount of edge crossings.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ICrossMinimizer
\end{lstlisting}
\subsubsection{All known subinterfaces}{CrossMinimizer\small{\refdefined{sugiyama.CrossMinimizer}}}
\subsubsection{All classes known to implement interface}{CrossMinimizer\small{\refdefined{sugiyama.CrossMinimizer}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{minimizeCrossings(ICrossMinimizerGraph)}
{\bf  minimizeCrossings}\\
\begin{lstlisting}[frame=none]
void minimizeCrossings(ICrossMinimizerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Rearranges vertices in the graph argument in order to remove the amount of crosses of their edges.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.ICrossMinimizerGraph}\index{ICrossMinimizerGraph@\textit{ ICrossMinimizerGraph}}Interface ICrossMinimizerGraph}{
\vskip .1in 
A LayeredGraph which additionally defines functions that can be used to minimize the crossings in the sugiyama-layout.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ICrossMinimizerGraph
 extends graphmodel.LayeredGraph\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{All classes known to implement interface}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getLayer(int)}
{\bf  getLayer}\\
\begin{lstlisting}[frame=none]
java.util.List getLayer(int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get all vertices from a certain layer.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerNum} -- the layer number to get all vertices from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of all vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayer(SugiyamaGraph.SugiyamaVertex)}
{\bf  getLayer}\\
\begin{lstlisting}[frame=none]
int getLayer(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the layer from the vertex
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to get its layer from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the layer number from this vertex 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayerCount()}
{\bf  getLayerCount}\\
\begin{lstlisting}[frame=none]
int getLayerCount()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the amount of layers.
}
\item{{\bf  Returns} -- 
the amount of layers that contain at least one vertex 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayers()}
{\bf  getLayers}\\
\begin{lstlisting}[frame=none]
java.util.List getLayers()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get all layers that contain vertices.
}
\item{{\bf  Returns} -- 
a list of lists of vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexCount(int)}
{\bf  getVertexCount}\\
\begin{lstlisting}[frame=none]
int getVertexCount(int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the number of vertices which are on a certain layer
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerNum} -- the layer number to get the vertex count from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the number of vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{swapVertices(SugiyamaGraph.SugiyamaVertex, SugiyamaGraph.SugiyamaVertex)}
{\bf  swapVertices}\\
\begin{lstlisting}[frame=none]
void swapVertices(SugiyamaGraph.SugiyamaVertex first,SugiyamaGraph.SugiyamaVertex second)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Swaps the position of two vertices that are on the same layer
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{first} -- first vertex to change position with}
   \item{
\texttt{second} -- second vertex to change position with}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.ICycleRemover}\index{ICycleRemover@\textit{ ICycleRemover}}Interface ICycleRemover}{
\vskip .1in 
This interfaces represents a class that generates a DAG(Directed Acyclic Graph) from a \texttt{\small DirectedGraph}{\small 
\refdefined{graphmodel.DirectedGraph}}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ICycleRemover
\end{lstlisting}
\subsubsection{All known subinterfaces}{CycleRemover\small{\refdefined{sugiyama.CycleRemover}}}
\subsubsection{All classes known to implement interface}{CycleRemover\small{\refdefined{sugiyama.CycleRemover}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{removeCycles(ICycleRemoverGraph)}
{\bf  removeCycles}\\
\begin{lstlisting}[frame=none]
java.util.Set removeCycles(ICycleRemoverGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Searches for a acyclic subgraph in the graph argument and reversed the direction of the edges that are not part of this subgraph.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input graph to remove cycles from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a set of edges whose direction has been reversed in order to remove cycles from the graph 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.ICycleRemoverGraph}\index{ICycleRemoverGraph@\textit{ ICycleRemoverGraph}}Interface ICycleRemoverGraph}{
\vskip .1in 
A DirectedGraph which additionally defines functions to remove cycles in the graph.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ICycleRemoverGraph
 extends graphmodel.DirectedGraph\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{All classes known to implement interface}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{isReversed(SugiyamaGraph.SugiyamaEdge)}
{\bf  isReversed}\\
\begin{lstlisting}[frame=none]
boolean isReversed(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns true if the specified edge is reversed, false otherwise
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the edge is reversed, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{reverseEdge(SugiyamaGraph.SugiyamaEdge)}
{\bf  reverseEdge}\\
\begin{lstlisting}[frame=none]
void reverseEdge(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Reverses the direction of a sugiyama edge. The underlying edge won't be reversed to avoid inconsistencies in the underlying graph Instead the reversing will be saved in the SugiyamaEdge. If the edge is already reversed it will be reversed again.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to reverse its direction}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.IEdgeDrawer}\index{IEdgeDrawer@\textit{ IEdgeDrawer}}Interface IEdgeDrawer}{
\vskip .1in 
This interface represents a class that takes a directed graph, as a SugiyamaClass. It removes dummy vertices and reverses previously reversed edges. Afterwards it assigns every edge points it must run through.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface IEdgeDrawer
\end{lstlisting}
\subsubsection{All known subinterfaces}{EdgeDrawer\small{\refdefined{sugiyama.EdgeDrawer}}}
\subsubsection{All classes known to implement interface}{EdgeDrawer\small{\refdefined{sugiyama.EdgeDrawer}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{drawEdges(IEdgeDrawerGraph)}
{\bf  drawEdges}\\
\begin{lstlisting}[frame=none]
void drawEdges(IEdgeDrawerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Draws the edges from the graph argument and reverses the edges, which have been reversed earlier, so they have now the correct direction.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.IEdgeDrawerGraph}\index{IEdgeDrawerGraph@\textit{ IEdgeDrawerGraph}}Interface IEdgeDrawerGraph}{
\vskip .1in 
A LayeredGraph which additionally defines functions draw the edges in the sugiyama-layout.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface IEdgeDrawerGraph
 extends graphmodel.LayeredGraph\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{All classes known to implement interface}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addEdgeCorner(SugiyamaGraph.SugiyamaEdge, int, int, int)}
{\bf  addEdgeCorner}\\
\begin{lstlisting}[frame=none]
void addEdgeCorner(SugiyamaGraph.SugiyamaEdge edge,int x,int y,int index)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Adds a new edge corner to the specified edge. The index specifies the position between other edge corners. Every edge corner is connected with the corners with index +/- 1 of it's index. Counting starts at 0 at the endpoint at the source vertex of the edge. End- and startpoint are also counted as corners
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to add a new corner}
   \item{
\texttt{x} -- the x coordinate of the corner}
   \item{
\texttt{y} -- the y coordinate of the corner}
   \item{
\texttt{index} -- the index on the edge of the corner}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getEdgeCorners(SugiyamaGraph.SugiyamaEdge)}
{\bf  getEdgeCorners}\\
\begin{lstlisting}[frame=none]
java.util.List getEdgeCorners(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns a list of points, which describe the coordinates of the edges
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the list of points of the corners on the edge 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getReplacedEdges()}
{\bf  getReplacedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set getReplacedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the set of replaced edges.
}
\item{{\bf  Returns} -- 
the set of replaced edges 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getReversedEdges()}
{\bf  getReversedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set getReversedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the set of all with \texttt{\small reverseEdge(E edge)} reversed edges.
}
\item{{\bf  Returns} -- 
the set of all reversed edges. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{removeEdgeCorner(SugiyamaGraph.SugiyamaEdge, int)}
{\bf  removeEdgeCorner}\\
\begin{lstlisting}[frame=none]
void removeEdgeCorner(SugiyamaGraph.SugiyamaEdge edge,int index)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Removes the corner on the specified edge at the index
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to remove the corner}
   \item{
\texttt{index} -- the index of the corner to remove}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{restoreAllEdges()}
{\bf  restoreAllEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set restoreAllEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Deletes the supplement edges, which have been created when an edge was reversed. Adds all reversed edges back to the set of edges and returns them.
}
\item{{\bf  Returns} -- 
the set of edges, which have been restored. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{restoreReplacedEdges()}
{\bf  restoreReplacedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set restoreReplacedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Deletes all dummy vertices and edges connecting dummy vertices. Adds the replaced edges back to set of edges.
}
\item{{\bf  Returns} -- 
the set of edges, which has been restored 
}%end item
\end{itemize}
}%end item
\item{ 
\index{reverseEdge(SugiyamaGraph.SugiyamaEdge)}
{\bf  reverseEdge}\\
\begin{lstlisting}[frame=none]
void reverseEdge(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Reverses the direction of an directed edge and returns it.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to return its direction}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.ILayerAssigner}\index{ILayerAssigner@\textit{ ILayerAssigner}}Interface ILayerAssigner}{
\vskip .1in 
This interface represents a class that takes a directed graph and assigns every vertex in it a layer.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ILayerAssigner
\end{lstlisting}
\subsubsection{All known subinterfaces}{LayerAssigner\small{\refdefined{sugiyama.LayerAssigner}}}
\subsubsection{All classes known to implement interface}{LayerAssigner\small{\refdefined{sugiyama.LayerAssigner}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addConstraints(Set)}
{\bf  addConstraints}\\
\begin{lstlisting}[frame=none]
void addConstraints(java.util.Set constraints)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Defines a set of constraints which should be considered by the algorithm.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{constraints} -- relative layer constraints the algorithm should consider}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{assignLayers(ILayerAssignerGraph)}
{\bf  assignLayers}\\
\begin{lstlisting}[frame=none]
void assignLayers(ILayerAssignerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Assigns every vertex in the graph parameter e relative height.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setMaxHeight(int)}
{\bf  setMaxHeight}\\
\begin{lstlisting}[frame=none]
void setMaxHeight(int height)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Reassigns the layer of vertices whose layer is greater than the height parameter.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{height} -- maximum height for vertices}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setMaxWidth(int)}
{\bf  setMaxWidth}\\
\begin{lstlisting}[frame=none]
void setMaxWidth(int width)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Reassigns the layer of vertices in case there are more than the width parameter in one layer.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{width} -- maximum amount of vertices in one layer}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.ILayerAssignerGraph}\index{ILayerAssignerGraph@\textit{ ILayerAssignerGraph}}Interface ILayerAssignerGraph}{
\vskip .1in 
A LayeredGraph which additionally defines functions to assign layers in the sugiyama-layout.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface ILayerAssignerGraph
 extends graphmodel.LayeredGraph\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{All classes known to implement interface}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{assignToLayer(SugiyamaGraph.SugiyamaVertex, int)}
{\bf  assignToLayer}\\
\begin{lstlisting}[frame=none]
void assignToLayer(SugiyamaGraph.SugiyamaVertex vertex,int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Assigns a vertex to a certain layer represented by a number.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to assign to a layer}
   \item{
\texttt{layerNum} -- the layer number to assign a vertex to}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayer(SugiyamaGraph.SugiyamaVertex)}
{\bf  getLayer}\\
\begin{lstlisting}[frame=none]
int getLayer(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the layer from the vertex
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to get its layer from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the layer number from this vertex 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexCount(int)}
{\bf  getVertexCount}\\
\begin{lstlisting}[frame=none]
int getVertexCount(int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the number of vertices which are on a certain layer
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerNum} -- the layer number to get the vertex count from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the number of vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.IVertexPositioner}\index{IVertexPositioner@\textit{ IVertexPositioner}}Interface IVertexPositioner}{
\vskip .1in 
This interface represents a class that takes a directed graph and position its vertices in order to look more clearly. (e.g. position vertices in a row or column) This step has to access the GraphicEngine to get the size of each vertex.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface IVertexPositioner
\end{lstlisting}
\subsubsection{All known subinterfaces}{VertexPositioner\small{\refdefined{sugiyama.VertexPositioner}}}
\subsubsection{All classes known to implement interface}{VertexPositioner\small{\refdefined{sugiyama.VertexPositioner}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{positionVertices(IVertexPositionerGraph)}
{\bf  positionVertices}\\
\begin{lstlisting}[frame=none]
void positionVertices(IVertexPositionerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets absolute coordinates for every vertex in the graph. Before this step the vertices are only positioned relatively to each other (layer and order in one layer)
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.IVertexPositionerGraph}\index{IVertexPositionerGraph@\textit{ IVertexPositionerGraph}}Interface IVertexPositionerGraph}{
\vskip .1in 
A LayeredGraph which additionally defines functions to position vertices in the sugiyama-layout.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface IVertexPositionerGraph
 extends graphmodel.LayeredGraph\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{All classes known to implement interface}{SugiyamaGraph\small{\refdefined{sugiyama.SugiyamaGraph}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{setLayerY(int, int)}
{\bf  setLayerY}\\
\begin{lstlisting}[frame=none]
void setLayerY(int layerN,int y)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the y-coordinate of all vertices on layer Y.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerN} -- the index of the layer}
   \item{
\texttt{y} -- the y-coordinate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setX(SugiyamaGraph.SugiyamaVertex, int)}
{\bf  setX}\\
\begin{lstlisting}[frame=none]
void setX(SugiyamaGraph.SugiyamaVertex vertex,int x)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the x-coordinate of the specified vertex
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to position}
   \item{
\texttt{x} -- the x-coordinate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.LayeredLayoutAlgorithm}\index{LayeredLayoutAlgorithm@\textit{ LayeredLayoutAlgorithm}}Interface LayeredLayoutAlgorithm}{
\vskip .1in 
A layout algorithm which is able to apply Layouts while keeping the notion of layers in addition to layout regular graphs.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface LayeredLayoutAlgorithm
 extends plugin.LayoutAlgorithm\end{lstlisting}
\subsubsection{All known subinterfaces}{SugiyamaLayoutAlgorithm\small{\refdefined{sugiyama.SugiyamaLayoutAlgorithm}}}
\subsubsection{All classes known to implement interface}{SugiyamaLayoutAlgorithm\small{\refdefined{sugiyama.SugiyamaLayoutAlgorithm}}}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{layoutLayeredGraph(LayeredGraph)}
{\bf  layoutLayeredGraph}\\
\begin{lstlisting}[frame=none]
void layoutLayeredGraph(graphmodel.LayeredGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Applies its layout to a graph as in \texttt{\small layout(G graph)} but keeps the notion of layers. The algorithm will assign every vertex a coordinate and every edge a path. Additionally every vertex will be assigned a position in a layer in the LayeredGraph. A possible application is drawing of recursive graphs.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the graph to apply the layout to}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.AbsoluteLayerConstraint}\index{AbsoluteLayerConstraint}Class AbsoluteLayerConstraint}{
\vskip .1in 
A absolute constraint, regarding layer assignment, for one set of vertices. Can describe if one set of vertices should be placed in one layer, in a range of layers. The constraint can be inverted, meaning it should not be placed on this layer. Additionally an exclusive flag can be set to mark that only this set of vertices should be placed on the selected range of layer. Consequently inverted and exclusive means all other vertices have to be placed in this range of layers.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class AbsoluteLayerConstraint
 extends java.lang.Object implements plugin.Constraint\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{AbsoluteLayerConstraint(Set, boolean, boolean, int, int)}
{\bf  AbsoluteLayerConstraint}\\
\begin{lstlisting}[frame=none]
public AbsoluteLayerConstraint(java.util.Set set,boolean inverted,boolean exclusive,int minLayer,int maxLayer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructs an AbsoluteLayerConstraint.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{set} -- set of sugiyama vertices to apply this constraint on}
   \item{
\texttt{inverted} -- invertes this constraint, if true}
   \item{
\texttt{exclusive} -- places only this set of vertices in this range of layers}
   \item{
\texttt{minLayer} -- lower bound of layer number}
   \item{
\texttt{maxLayer} -- upper bound of layer number}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getMaxLayer()}
{\bf  getMaxLayer}\\
\begin{lstlisting}[frame=none]
public int getMaxLayer()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the maximum layer the vertices should be on.
}
\item{{\bf  Returns} -- 
the maximum layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getMinLayer()}
{\bf  getMinLayer}\\
\begin{lstlisting}[frame=none]
public int getMinLayer()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the minimum layer the vertices should be on.
}
\item{{\bf  Returns} -- 
the minimum layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Constraint{\small \refdefined{plugin.Constraint}} }

The name of the constraint
}
\item{{\bf  Returns} -- 
the name 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertices()}
{\bf  getVertices}\\
\begin{lstlisting}[frame=none]
public java.util.Set getVertices()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the set of vertices which should be affected by the constraint.
}
\item{{\bf  Returns} -- 
the set of vertices 
}%end item
\end{itemize}
}%end item
\item{ 
\index{isExclusive()}
{\bf  isExclusive}\\
\begin{lstlisting}[frame=none]
public boolean isExclusive()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns true if the set of vertices should be affected by the constraint exclusively.
}
\item{{\bf  Returns} -- 
true if exclusive 
}%end item
\end{itemize}
}%end item
\item{ 
\index{isInverted()}
{\bf  isInverted}\\
\begin{lstlisting}[frame=none]
public boolean isInverted()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns true if the constraint should be inverted.
}
\item{{\bf  Returns} -- 
true if inverted 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.CrossMinimizer}\index{CrossMinimizer}Class CrossMinimizer}{
\vskip .1in 
This class takes a Sugiyama Graph and rearranges its vertices on each layer to minimize the amount of edge crossings.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class CrossMinimizer
 extends java.lang.Object implements ICrossMinimizer\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{CrossMinimizer()}
{\bf  CrossMinimizer}\\
\begin{lstlisting}[frame=none]
public CrossMinimizer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{minimizeCrossings(ICrossMinimizerGraph)}
{\bf  minimizeCrossings}\\
\begin{lstlisting}[frame=none]
void minimizeCrossings(ICrossMinimizerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICrossMinimizer{\small \refdefined{sugiyama.ICrossMinimizer}} }

Rearranges vertices in the graph argument in order to remove the amount of crosses of their edges.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.CycleRemover}\index{CycleRemover}Class CycleRemover}{
\vskip .1in 
This class takes a directed Graph G = (V, E) and removes a set of edges E\_\ so that the resulting Graph G' = (V, E\textbackslash E\_) is a DAG(Directed Acyclic Graph).\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class CycleRemover
 extends java.lang.Object implements ICycleRemover\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{CycleRemover()}
{\bf  CycleRemover}\\
\begin{lstlisting}[frame=none]
public CycleRemover()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{removeCycles(ICycleRemoverGraph)}
{\bf  removeCycles}\\
\begin{lstlisting}[frame=none]
java.util.Set removeCycles(ICycleRemoverGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICycleRemover{\small \refdefined{sugiyama.ICycleRemover}} }

Searches for a acyclic subgraph in the graph argument and reversed the direction of the edges that are not part of this subgraph.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input graph to remove cycles from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a set of edges whose direction has been reversed in order to remove cycles from the graph 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.EdgeDrawer}\index{EdgeDrawer}Class EdgeDrawer}{
\vskip .1in 
This class takes a directed graph, as a SugiyamaClass. It removes dummy vertices and reverses previously reversed edges. Afterwards it assigns every edge points it must run through.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class EdgeDrawer
 extends java.lang.Object implements IEdgeDrawer\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EdgeDrawer()}
{\bf  EdgeDrawer}\\
\begin{lstlisting}[frame=none]
public EdgeDrawer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{drawEdges(IEdgeDrawerGraph)}
{\bf  drawEdges}\\
\begin{lstlisting}[frame=none]
void drawEdges(IEdgeDrawerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawer{\small \refdefined{sugiyama.IEdgeDrawer}} }

Draws the edges from the graph argument and reverses the edges, which have been reversed earlier, so they have now the correct direction.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.LayerAssigner}\index{LayerAssigner}Class LayerAssigner}{
\vskip .1in 
This class takes a directed graph and assigns every vertex in it a layer.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class LayerAssigner
 extends java.lang.Object implements ILayerAssigner\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{LayerAssigner()}
{\bf  LayerAssigner}\\
\begin{lstlisting}[frame=none]
public LayerAssigner()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addConstraints(Set)}
{\bf  addConstraints}\\
\begin{lstlisting}[frame=none]
void addConstraints(java.util.Set constraints)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssigner{\small \refdefined{sugiyama.ILayerAssigner}} }

Defines a set of constraints which should be considered by the algorithm.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{constraints} -- relative layer constraints the algorithm should consider}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{assignLayers(ILayerAssignerGraph)}
{\bf  assignLayers}\\
\begin{lstlisting}[frame=none]
void assignLayers(ILayerAssignerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssigner{\small \refdefined{sugiyama.ILayerAssigner}} }

Assigns every vertex in the graph parameter e relative height.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setMaxHeight(int)}
{\bf  setMaxHeight}\\
\begin{lstlisting}[frame=none]
void setMaxHeight(int height)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssigner{\small \refdefined{sugiyama.ILayerAssigner}} }

Reassigns the layer of vertices whose layer is greater than the height parameter.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{height} -- maximum height for vertices}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setMaxWidth(int)}
{\bf  setMaxWidth}\\
\begin{lstlisting}[frame=none]
void setMaxWidth(int width)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssigner{\small \refdefined{sugiyama.ILayerAssigner}} }

Reassigns the layer of vertices in case there are more than the width parameter in one layer.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{width} -- maximum amount of vertices in one layer}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.RelativeLayerConstraint}\index{RelativeLayerConstraint}Class RelativeLayerConstraint}{
\vskip .1in 
A relative constraint, regarding layer assignment, between to sets of vertices. Can describe if one set of vertices should be on top of the other. When the exact is set a layer distance can be set.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class RelativeLayerConstraint
 extends java.lang.Object implements plugin.Constraint\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{RelativeLayerConstraint(Set, Set, boolean, int)}
{\bf  RelativeLayerConstraint}\\
\begin{lstlisting}[frame=none]
public RelativeLayerConstraint(java.util.Set top,java.util.Set bottom,boolean direct,int distance)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructs a new RelativeLayerConstraint, sets the top and bottom vertices, whether its direct and the distance.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{top} -- The top vertices.}
   \item{
\texttt{bottom} -- The bottom vertices.}
   \item{
\texttt{direct} -- True is direct, false is not direct.}
   \item{
\texttt{distance} -- The distance between top and bottom layer.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{bottomSet()}
{\bf  bottomSet}\\
\begin{lstlisting}[frame=none]
public java.util.Set bottomSet()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the set which should be below.
}
\item{{\bf  Returns} -- 
the bottom layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getDistance()}
{\bf  getDistance}\\
\begin{lstlisting}[frame=none]
public int getDistance() throws java.lang.IllegalStateException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the distance the two sets should be apart, if this constraint is exact.
}
\item{{\bf  Returns} -- 
the number of layers between the sets 
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{java.lang.IllegalStateException} -- if the set is not exact}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the name of the layout constraint
}
\end{itemize}
}%end item
\item{ 
\index{isExact()}
{\bf  isExact}\\
\begin{lstlisting}[frame=none]
public boolean isExact()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns true if the constraints describes an exact distance between the two sets, false otherwise.
}
\item{{\bf  Returns} -- 
true if exact 
}%end item
\end{itemize}
}%end item
\item{ 
\index{topSet()}
{\bf  topSet}\\
\begin{lstlisting}[frame=none]
public java.util.Set topSet()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the set which should be on top.
}
\item{{\bf  Returns} -- 
the top layer 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaGraph}\index{SugiyamaGraph}Class SugiyamaGraph}{
\vskip .1in 
The SugiyamaGraph is a wrapper for a directed graph to enable easy and fast accessibility of attributes and constructs needed during the computation of the hierarchical layout of a directed graph. All vertices are assigned to a layer. The positions of the vertices can be viewed as a grid (with varying widths per layer).\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SugiyamaGraph
 extends java.lang.Object implements ICycleRemoverGraph, ILayerAssignerGraph, ICrossMinimizerGraph, IVertexPositionerGraph, IEdgeDrawerGraph\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SugiyamaGraph(G)}
{\bf  SugiyamaGraph}\\
\begin{lstlisting}[frame=none]
public SugiyamaGraph(graphmodel.DirectedGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructs a new SugiyamaGraph and sets the Graph which is the underlying representation. To fulfill the invariant that all vertices are assigned to a layer, all vertices will be assigned to layer 0.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the graph used as underlying representation.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addEdgeCorner(SugiyamaGraph.SugiyamaEdge, int, int, int)}
{\bf  addEdgeCorner}\\
\begin{lstlisting}[frame=none]
void addEdgeCorner(SugiyamaGraph.SugiyamaEdge edge,int x,int y,int index)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Adds a new edge corner to the specified edge. The index specifies the position between other edge corners. Every edge corner is connected with the corners with index +/- 1 of it's index. Counting starts at 0 at the endpoint at the source vertex of the edge. End- and startpoint are also counted as corners
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to add a new corner}
   \item{
\texttt{x} -- the x coordinate of the corner}
   \item{
\texttt{y} -- the y coordinate of the corner}
   \item{
\texttt{index} -- the index on the edge of the corner}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{addToFastGraphAccessor(FastGraphAccessor)}
{\bf  addToFastGraphAccessor}\\
\begin{lstlisting}[frame=none]
public void addToFastGraphAccessor(graphmodel.FastGraphAccessor fga)\end{lstlisting} %end signature
}%end item
\item{ 
\index{assignToLayer(SugiyamaGraph.SugiyamaVertex, int)}
{\bf  assignToLayer}\\
\begin{lstlisting}[frame=none]
void assignToLayer(SugiyamaGraph.SugiyamaVertex vertex,int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssignerGraph{\small \refdefined{sugiyama.ILayerAssignerGraph}} }

Assigns a vertex to a certain layer represented by a number.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to assign to a layer}
   \item{
\texttt{layerNum} -- the layer number to assign a vertex to}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{edgesOf(SugiyamaGraph.SugiyamaVertex)}
{\bf  edgesOf}\\
\begin{lstlisting}[frame=none]
public java.util.Set edgesOf(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getEdgeCorners(SugiyamaGraph.SugiyamaEdge)}
{\bf  getEdgeCorners}\\
\begin{lstlisting}[frame=none]
java.util.List getEdgeCorners(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Returns a list of points, which describe the coordinates of the edges
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the list of points of the corners on the edge 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getEdgeSet()}
{\bf  getEdgeSet}\\
\begin{lstlisting}[frame=none]
public java.util.Set getEdgeSet()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getFastGraphAccessor()}
{\bf  getFastGraphAccessor}\\
\begin{lstlisting}[frame=none]
public graphmodel.FastGraphAccessor getFastGraphAccessor()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getHeight()}
{\bf  getHeight}\\
\begin{lstlisting}[frame=none]
public int getHeight()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getID()}
{\bf  getID}\\
\begin{lstlisting}[frame=none]
public java.lang.Integer getID()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLayer(int)}
{\bf  getLayer}\\
\begin{lstlisting}[frame=none]
java.util.List getLayer(int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICrossMinimizerGraph{\small \refdefined{sugiyama.ICrossMinimizerGraph}} }

Get all vertices from a certain layer.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerNum} -- the layer number to get all vertices from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of all vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayer(SugiyamaGraph.SugiyamaVertex)}
{\bf  getLayer}\\
\begin{lstlisting}[frame=none]
int getLayer(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssignerGraph{\small \refdefined{sugiyama.ILayerAssignerGraph}} }

Get the layer from the vertex
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to get its layer from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the layer number from this vertex 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayerCount()}
{\bf  getLayerCount}\\
\begin{lstlisting}[frame=none]
int getLayerCount()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICrossMinimizerGraph{\small \refdefined{sugiyama.ICrossMinimizerGraph}} }

Get the amount of layers.
}
\item{{\bf  Returns} -- 
the amount of layers that contain at least one vertex 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayers()}
{\bf  getLayers}\\
\begin{lstlisting}[frame=none]
java.util.List getLayers()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICrossMinimizerGraph{\small \refdefined{sugiyama.ICrossMinimizerGraph}} }

Get all layers that contain vertices.
}
\item{{\bf  Returns} -- 
a list of lists of vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLayerWidth(int)}
{\bf  getLayerWidth}\\
\begin{lstlisting}[frame=none]
public int getLayerWidth(int layerN)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getMaxWidth()}
{\bf  getMaxWidth}\\
\begin{lstlisting}[frame=none]
public int getMaxWidth()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getReplacedEdges()}
{\bf  getReplacedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set getReplacedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Returns the set of replaced edges.
}
\item{{\bf  Returns} -- 
the set of replaced edges 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getReversedEdges()}
{\bf  getReversedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set getReversedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Returns the set of all with \texttt{\small reverseEdge(E edge)} reversed edges.
}
\item{{\bf  Returns} -- 
the set of all reversed edges. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubgraphs()}
{\bf  getSubgraphs}\\
\begin{lstlisting}[frame=none]
public java.util.List getSubgraphs()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getVertexCount(int)}
{\bf  getVertexCount}\\
\begin{lstlisting}[frame=none]
int getVertexCount(int layerNum)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ILayerAssignerGraph{\small \refdefined{sugiyama.ILayerAssignerGraph}} }

Get the number of vertices which are on a certain layer
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerNum} -- the layer number to get the vertex count from}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the number of vertices which are on this layer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexSet()}
{\bf  getVertexSet}\\
\begin{lstlisting}[frame=none]
public java.util.Set getVertexSet()\end{lstlisting} %end signature
}%end item
\item{ 
\index{incomingEdgesOf(SugiyamaGraph.SugiyamaVertex)}
{\bf  incomingEdgesOf}\\
\begin{lstlisting}[frame=none]
public java.util.Set incomingEdgesOf(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
}%end item
\item{ 
\index{indegreeOf(SugiyamaGraph.SugiyamaVertex)}
{\bf  indegreeOf}\\
\begin{lstlisting}[frame=none]
public java.lang.Integer indegreeOf(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
}%end item
\item{ 
\index{isReversed(SugiyamaGraph.SugiyamaEdge)}
{\bf  isReversed}\\
\begin{lstlisting}[frame=none]
boolean isReversed(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICycleRemoverGraph{\small \refdefined{sugiyama.ICycleRemoverGraph}} }

Returns true if the specified edge is reversed, false otherwise
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the edge is reversed, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{outdegreeOf(SugiyamaGraph.SugiyamaVertex)}
{\bf  outdegreeOf}\\
\begin{lstlisting}[frame=none]
public java.lang.Integer outdegreeOf(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
}%end item
\item{ 
\index{outgoingEdgesOf(SugiyamaGraph.SugiyamaVertex)}
{\bf  outgoingEdgesOf}\\
\begin{lstlisting}[frame=none]
public java.util.Set outgoingEdgesOf(SugiyamaGraph.SugiyamaVertex vertex)\end{lstlisting} %end signature
}%end item
\item{ 
\index{removeEdgeCorner(SugiyamaGraph.SugiyamaEdge, int)}
{\bf  removeEdgeCorner}\\
\begin{lstlisting}[frame=none]
void removeEdgeCorner(SugiyamaGraph.SugiyamaEdge edge,int index)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Removes the corner on the specified edge at the index
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to remove the corner}
   \item{
\texttt{index} -- the index of the corner to remove}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{restoreAllEdges()}
{\bf  restoreAllEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set restoreAllEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Deletes the supplement edges, which have been created when an edge was reversed. Adds all reversed edges back to the set of edges and returns them.
}
\item{{\bf  Returns} -- 
the set of edges, which have been restored. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{restoreReplacedEdges()}
{\bf  restoreReplacedEdges}\\
\begin{lstlisting}[frame=none]
java.util.Set restoreReplacedEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IEdgeDrawerGraph{\small \refdefined{sugiyama.IEdgeDrawerGraph}} }

Deletes all dummy vertices and edges connecting dummy vertices. Adds the replaced edges back to set of edges.
}
\item{{\bf  Returns} -- 
the set of edges, which has been restored 
}%end item
\end{itemize}
}%end item
\item{ 
\index{reverseEdge(SugiyamaGraph.SugiyamaEdge)}
{\bf  reverseEdge}\\
\begin{lstlisting}[frame=none]
void reverseEdge(SugiyamaGraph.SugiyamaEdge edge)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICycleRemoverGraph{\small \refdefined{sugiyama.ICycleRemoverGraph}} }

Reverses the direction of a sugiyama edge. The underlying edge won't be reversed to avoid inconsistencies in the underlying graph Instead the reversing will be saved in the SugiyamaEdge. If the edge is already reversed it will be reversed again.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{edge} -- the edge to reverse its direction}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setLayerY(int, int)}
{\bf  setLayerY}\\
\begin{lstlisting}[frame=none]
void setLayerY(int layerN,int y)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IVertexPositionerGraph{\small \refdefined{sugiyama.IVertexPositionerGraph}} }

Sets the y-coordinate of all vertices on layer Y.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{layerN} -- the index of the layer}
   \item{
\texttt{y} -- the y-coordinate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setX(SugiyamaGraph.SugiyamaVertex, int)}
{\bf  setX}\\
\begin{lstlisting}[frame=none]
void setX(SugiyamaGraph.SugiyamaVertex vertex,int x)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IVertexPositionerGraph{\small \refdefined{sugiyama.IVertexPositionerGraph}} }

Sets the x-coordinate of the specified vertex
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{vertex} -- the vertex to position}
   \item{
\texttt{x} -- the x-coordinate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{swapVertices(SugiyamaGraph.SugiyamaVertex, SugiyamaGraph.SugiyamaVertex)}
{\bf  swapVertices}\\
\begin{lstlisting}[frame=none]
void swapVertices(SugiyamaGraph.SugiyamaVertex first,SugiyamaGraph.SugiyamaVertex second)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from ICrossMinimizerGraph{\small \refdefined{sugiyama.ICrossMinimizerGraph}} }

Swaps the position of two vertices that are on the same layer
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{first} -- first vertex to change position with}
   \item{
\texttt{second} -- second vertex to change position with}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaGraph.DummyVertex}\index{SugiyamaGraph.DummyVertex}Class SugiyamaGraph.DummyVertex}{
\vskip .1in 
A supplement vertex which is part of a \texttt{\small SugiyamaGraph.SupplementPath}{\small 
\refdefined{sugiyama.SugiyamaGraph.SupplementPath}}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public static class SugiyamaGraph.DummyVertex
 extends graphmodel.DefaultVertex\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{DummyVertex()}
{\bf  DummyVertex}\\
\begin{lstlisting}[frame=none]
public DummyVertex()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaGraph.SugiyamaEdge}\index{SugiyamaGraph.SugiyamaEdge}Class SugiyamaGraph.SugiyamaEdge}{
\vskip .1in 
A wrapper class for directed edges to implement additional functionality to apply the sugiyama layout to the SugiyamaGraph containing them.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public static class SugiyamaGraph.SugiyamaEdge
 extends graphmodel.DirectedEdge\end{lstlisting}
}
\subsection{\label{sugiyama.SugiyamaGraph.SugiyamaVertex}\index{SugiyamaGraph.SugiyamaVertex}Class SugiyamaGraph.SugiyamaVertex}{
\vskip .1in 
A wrapper class for vertices used in the sugiyama framework. A SugiyamaVertex can be a \texttt{\small DefaultVertex}{\small 
\refdefined{graphmodel.DefaultVertex}} or a \texttt{\small SugiyamaGraph.DummyVertex}{\small 
\refdefined{sugiyama.SugiyamaGraph.DummyVertex}}\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public static class SugiyamaGraph.SugiyamaVertex
 extends graphmodel.DefaultVertex\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SugiyamaVertex()}
{\bf  SugiyamaVertex}\\
\begin{lstlisting}[frame=none]
public SugiyamaVertex()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{isDummyVertex()}
{\bf  isDummyVertex}\\
\begin{lstlisting}[frame=none]
public boolean isDummyVertex()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaGraph.SupplementEdge}\index{SugiyamaGraph.SupplementEdge}Class SugiyamaGraph.SupplementEdge}{
\vskip .1in 
A supplement edge which is part of a \texttt{\small SugiyamaGraph.SupplementPath}{\small 
\refdefined{sugiyama.SugiyamaGraph.SupplementPath}}.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public static class SugiyamaGraph.SupplementEdge
 extends graphmodel.DirectedEdge\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SupplementEdge()}
{\bf  SupplementEdge}\\
\begin{lstlisting}[frame=none]
public SupplementEdge()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaGraph.SupplementPath}\index{SugiyamaGraph.SupplementPath}Class SugiyamaGraph.SupplementPath}{
\vskip .1in 
A supplement path for connecting vertices, which are more than one layer apart. They are stored in the SugiyamaEdge along with the substituted edge.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public static class SugiyamaGraph.SupplementPath
 extends graphmodel.DirectedEdge\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SupplementPath()}
{\bf  SupplementPath}\\
\begin{lstlisting}[frame=none]
public SupplementPath()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getDummyVertices()}
{\bf  getDummyVertices}\\
\begin{lstlisting}[frame=none]
public java.util.List getDummyVertices()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the list of vertices on the path sorted from source to target excluding the source and target.
}
\item{{\bf  Returns} -- 
the list of vertices 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getEdges()}
{\bf  getEdges}\\
\begin{lstlisting}[frame=none]
public java.util.List getEdges()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the list of edges on the path from source to target
}
\item{{\bf  Returns} -- 
the edges 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLength()}
{\bf  getLength}\\
\begin{lstlisting}[frame=none]
public int getLength()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Returns the number of vertices including source and target.
}
\item{{\bf  Returns} -- 
the length of the path 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaLayoutAlgorithm}\index{SugiyamaLayoutAlgorithm}Class SugiyamaLayoutAlgorithm}{
\vskip .1in 
This class supports a customizable implementation of the Sugiyama-framework. The single stages of the framework can be chosen individually. Additionally this class tries to follow the given constraints, if possible.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SugiyamaLayoutAlgorithm
 extends java.lang.Object implements LayeredLayoutAlgorithm\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SugiyamaLayoutAlgorithm()}
{\bf  SugiyamaLayoutAlgorithm}\\
\begin{lstlisting}[frame=none]
public SugiyamaLayoutAlgorithm()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addAbsoluteLayerConstraint(AbsoluteLayerConstraint)}
{\bf  addAbsoluteLayerConstraint}\\
\begin{lstlisting}[frame=none]
public void addAbsoluteLayerConstraint(AbsoluteLayerConstraint constraint)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Adds an \texttt{\small AbsoluteLayerConstraint}{\small 
\refdefined{sugiyama.AbsoluteLayerConstraint}} to the set of constraints which should be followed.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{constraint} -- the constraint to follow}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{addRelativeLayerConstraint(RelativeLayerConstraint)}
{\bf  addRelativeLayerConstraint}\\
\begin{lstlisting}[frame=none]
public void addRelativeLayerConstraint(RelativeLayerConstraint constraint)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Adds an \texttt{\small RelativeLayerConstraint}{\small 
\refdefined{sugiyama.RelativeLayerConstraint}} to the set of constraints which should be followed.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{constraint} -- the constraint to follow}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSettings()}
{\bf  getSettings}\\
\begin{lstlisting}[frame=none]
public parameter.Settings getSettings()\end{lstlisting} %end signature
}%end item
\item{ 
\index{layout(G)}
{\bf  layout}\\
\begin{lstlisting}[frame=none]
public void layout(graphmodel.DirectedGraph graph)\end{lstlisting} %end signature
}%end item
\item{ 
\index{layoutLayeredGraph(LayeredGraph)}
{\bf  layoutLayeredGraph}\\
\begin{lstlisting}[frame=none]
void layoutLayeredGraph(graphmodel.LayeredGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from LayeredLayoutAlgorithm{\small \refdefined{sugiyama.LayeredLayoutAlgorithm}} }

Applies its layout to a graph as in \texttt{\small layout(G graph)} but keeps the notion of layers. The algorithm will assign every vertex a coordinate and every edge a path. Additionally every vertex will be assigned a position in a layer in the LayeredGraph. A possible application is drawing of recursive graphs.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the graph to apply the layout to}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setCrossMinimizer(ICrossMinimizer)}
{\bf  setCrossMinimizer}\\
\begin{lstlisting}[frame=none]
public void setCrossMinimizer(ICrossMinimizer minimizer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the algorithm for cross minimization used when applying the layout
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{minimizer} -- the cross minimization algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setCycleRemover(ICycleRemover)}
{\bf  setCycleRemover}\\
\begin{lstlisting}[frame=none]
public void setCycleRemover(ICycleRemover remover)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the algorithm to remove all cycles for a graph to layout used when applying the layout
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{remover} -- the algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setEdgeDrawer(IEdgeDrawer)}
{\bf  setEdgeDrawer}\\
\begin{lstlisting}[frame=none]
public void setEdgeDrawer(IEdgeDrawer drawer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the algorithm for edge drawing used when applying the layout
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{drawer} -- the edge drawing algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setLayerAssigner(ILayerAssigner)}
{\bf  setLayerAssigner}\\
\begin{lstlisting}[frame=none]
public void setLayerAssigner(ILayerAssigner assigner)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the algorithm for layer assigning used when applying the layout
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{assigner} -- the layer assign algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setVertexPositioner(IVertexPositioner)}
{\bf  setVertexPositioner}\\
\begin{lstlisting}[frame=none]
public void setVertexPositioner(IVertexPositioner positioner)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Sets the algorithm for vertex positioning used when applying the layout
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{positioner} -- the positioning algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.SugiyamaPlugin}\index{SugiyamaPlugin}Class SugiyamaPlugin}{
\vskip .1in 
A plugin for GAns that supplies a layout algorithm based on the Sugiyama-framework.\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SugiyamaPlugin
 extends java.lang.Object implements plugin.Plugin\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SugiyamaPlugin()}
{\bf  SugiyamaPlugin}\\
\begin{lstlisting}[frame=none]
public SugiyamaPlugin()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEdgeFilter()}
{\bf  getEdgeFilter}\\
\begin{lstlisting}[frame=none]
java.util.List getEdgeFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns all by the plugin provided \texttt{\small EdgeFilter}{\small 
\refdefined{plugin.EdgeFilter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
the list of provided edge filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getExporter()}
{\bf  getExporter}\\
\begin{lstlisting}[frame=none]
java.util.List getExporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns all by the plugin provided \texttt{\small Exporter}{\small 
\refdefined{plugin.Exporter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
a list of provided exporter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getImporter()}
{\bf  getImporter}\\
\begin{lstlisting}[frame=none]
java.util.List getImporter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns all by the plugin provided \texttt{\small Importer}{\small 
\refdefined{plugin.Importer}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
a list of provided importer 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getName()}
{\bf  getName}\\
\begin{lstlisting}[frame=none]
java.lang.String getName()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns the name of the plugin. Uniqueness can't be assumed.
}
\item{{\bf  Returns} -- 
the name of the plugin 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getVertexFilter()}
{\bf  getVertexFilter}\\
\begin{lstlisting}[frame=none]
java.util.List getVertexFilter()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns all by the plugin provided \texttt{\small VertexFilter}{\small 
\refdefined{plugin.VertexFilter}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
the list of provided vertex filter 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getWorkspaceOptions()}
{\bf  getWorkspaceOptions}\\
\begin{lstlisting}[frame=none]
java.util.List getWorkspaceOptions()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Returns all provided by the plugin \texttt{\small WorkspaceOption}{\small 
\refdefined{plugin.WorkspaceOption}}. If none are provided returns \texttt{\small null} or an empty list.
}
\item{{\bf  Returns} -- 
The list of provided workspace options 
}%end item
\end{itemize}
}%end item
\item{ 
\index{load()}
{\bf  load}\\
\begin{lstlisting}[frame=none]
void load()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from plugin.Plugin{\small \refdefined{plugin.Plugin}} }

Called after all plugins have been constructed. "Inter-Plugin" communication, like registering of layouts for graphs in other plugins should be executed in here.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{sugiyama.VertexPositioner}\index{VertexPositioner}Class VertexPositioner}{
\vskip .1in 
This class takes a directed graph and position its vertices in order to look more clearly. (e.g. position vertices in a row or column)\vskip .1in 
\subsubsection{Declaration}{
\begin{lstlisting}[frame=none]
public class VertexPositioner
 extends java.lang.Object implements IVertexPositioner\end{lstlisting}
\subsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{VertexPositioner()}
{\bf  VertexPositioner}\\
\begin{lstlisting}[frame=none]
public VertexPositioner()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{positionVertices(IVertexPositionerGraph)}
{\bf  positionVertices}\\
\begin{lstlisting}[frame=none]
void positionVertices(IVertexPositionerGraph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from IVertexPositioner{\small \refdefined{sugiyama.IVertexPositioner}} }

Sets absolute coordinates for every vertex in the graph. Before this step the vertices are only positioned relatively to each other (layer and order in one layer)
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\printindex
