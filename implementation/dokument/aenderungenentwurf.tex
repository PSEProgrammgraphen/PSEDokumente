\chapter{Änderungen am Entwurf}
\label{ch:aenderungen}

\newcounter{cnr}
\newcommand\change[2]{\textbf{\arabic{cnr}}\addtocounter{cnr}{1}. & \textbf{Aktion:} & #1 \\ & \textbf{Grund:} & #2 \\ [1ex] }
	
\section{General}
\setcounter{cnr}{1}

\begin{longtable}{llp{0.8\linewidth}}
	\change	{Methode \textit{getGraphBuilder()} von \textit{IVertexBuilder}  \textit{IGraphBuilder} verschoben.} 
			{Dadurch können hierachische Graphen einfacher erstellt werden, da der \textit{IGraphBuilder} den \textit{IGraphModelBuilder} kennt.}
	\change	{Collabsable Graph Interface hinzugefügt.} 
			{Zwischen einem zusammengeklappten Subgraphen und einer \textit{CompoundVertex}(z.B. FieldAccess) war nicht zu unterscheiden. Durch die \textit{CollapsedVertex} und ihre speziellen Subklassen ist die genaue Unterscheidung möglich.}
	\change	{Abhängigkeiten zwischen \textit{JoanaGraphModelBuilder}, \textit{JoanaGraphBuilder}, \textit{JoanaVertexBuilder} und \textit{JoanaEdgeBuilder} hinzugefügt.} 
			{Jede Builder Klasse muss wissen von welchem Builder sie erstellt wurde, um das erstellte Produkt (z.B. \textit{JoanaVertex} oder \textit{JoanaEdge}) bei seiner Elternklasse abspeichern zu können.}
	\change	{\textit{AbstractPluginBase} hinzugefügt.} 
			{Die meisten Funktionen in den speziellen Plugins sind fast leer, müssen aber überschrieben werden. Die \textit{AbstractPluginBase} reduziert diesen redundanten Code.}
	\change	{\textit{build()}-Funktionen aus \textit{IGraphBuilder}, \textit{IVertexBuilder} und \textit{IEdgeBuilder} entfernt.} 
			{\textit{build()} wird nun nur auf den \textit{IGraphModelBuilder} aufgerufen, welcher die speziellen build-Funktionen der konkreten Klassen rekursiv aufruft.}
	\change	{\textit{nodeKind}(String) aus \textit{JoanaVertex} und \textit{edgeKind}(String) aus \textit{JoanaEdge} durch jeweils einen Enum ersetzt und die Interfaces entsprechend angepasst.} 
			{Die genauen Werte die \textit{nodeKind}/\textit{edgeKind} annehmen können sind zur Compile-Zeit festgelegt. Dadurch können bestimmte Werte, wie Farbe und potentiell maximale Breite von Knoten nun durch den Typen festgelegt werden.}
	\change	{Jede \textit{GraphView} besitzt ihre eigene \textit{GraphViewGraphFactory}.}
			{Die \textit{GraphViewGraphFactory} bietet Zugriff mittels eines Mappings von GUI-Elementen auf die Modelelementen und auf den dargestellten Graph.}
	\change	{\textit{SerializedGraph} verschoben. Der angezeigte Graph wird nun von der \textit{GraphViewGraphFactory} serialisiert und im Model.} 
			{Die \textit{GraphViewGraphFactory} besitzt mehr Information (z.B. Farbe, Gruppe usw.) über den Graphen als das Model. Diese Informationen sind vor allem für den \textit{SvgExporter} wichtig.}
	\change	{Added class DefaultDirectedEdge and changed DirectedEdge from class to interface. Changed occurences of DirectedEdge to DefaultDirectedEdge in most cases in whole project.} 
			{There was a need of an interface of DirectedEdge (Jonas M)}
	\change	{\textit{getColor()} in \textit{Edge} und \textit{Vertex} hinzugefügt} 
			{Die Farbe muss von der \textit{Edge}/\textit{Vertex} vorgegeben werden, damit die GUI verschiedene Farben vergeben kann, \textit{JoanaEdge} und \textit{JoanaVertex} geben jeweils eine Farbe zurück, die von ihrem Typ bestimmt wird.}
	\change	{Aktuelle \textit{LayoutOption} wird in \textit{GraphView} gespeichert} 
			{Um zu wissen welcher Layoutalgorithmus zuletzt angewendet wurde und um diesen wiederholt anwenden zu können. Dies ist unter anderem bei der Collapse bzw. Expand Funktion und dem ändern der Properties nötig.}
	\change	{Die Realisierung von Gruppen wurde in die GUI verschoben und jede \textit{VertexShape} speichert ihren VertexStyle}
			{Da Gruppen nicht direkt mit dem darunter liegenden Datenmodel zusammenhängen, werden sie komplett in der GUI realisiert. Dazu wird für eine bestimmte Untermenge der Knoten eine von JavaFX definierter Style, im CSS Format, gesetzt. Dieser wird in der \textit{VertexShape} gespeichert und mittels \textit{getVertexStyle()} und \textit{setVertexStyle()} zugegriffen.}
			
	\change {Klasse \textit{Point} zu \textit{IntegerPoint} geändert, Klasse \textit{DoublePoint} hinzugefügt.}
			{In vielen Fällen war ein Punkt mit double Argumenten nötig, daher wurde einer für Integer und einer für double gemacht.}
\end{longtable}

\section{Sugiyama}
\label{sec:change_sugiyama}
\setcounter{cnr}{1}

\begin{tabular}{llp{0.8\linewidth}}
	
	\change {Interface \textit{ISugiyamaVertex} hinzugefügt. Außerdem implementieren \textit{SugiyamaVertex} und 
			\textit{DummyVertex} dieses Interface.}
			{Es war nötig, \textit{SugiyamaVertex} und \textit{DummyVertex} in einer Sammlung gleich zu behandeln.}
			
	\change {Interface \textit{ISugiyamaEdge} hinzugefügt. Außerdem implementieren \textit{SugiyamaEdge} und
			\textit{SupplementEdge} dieses Interface.}
			{Es war nötig, \textit{SugiyamaEdge} und \textit{SupplementEdge} in einer Sammlung gleich zu behandeln.}
			
	\change {Interface \textit{ISugiyamaStepGraph} hinzugefügt, welches das Interface \textit{LayeredGraph} erweitert.
			Die Interfaces \textit{ILayerAssignerGraph}, \textit{ICrossMinimizerGraph}, \textit{IVertexPositionerGraph} und \textit{IEdgeDrawerGraph} erweitern nun \textit{ISugiyamaStepGraph} anstelle von \textit{LayeredGraph}.}
			{Gibt den einzelnen Phasen mehr notwendige Zugriffe auf Funktionen im \textit{SugiyamaGraph}, da in vielen
			Phasen für die Durchführung nötige Methodenzugriffe fehlten.}
	
	\change {Klasse \textit{Point} aus dem sugiyama-Paket in das Paket \textit{shared/src/main/java/edu.kit.student.util}
			verschoben.}
			{Nicht nur der Sugiyama braucht Punkte, daher wurde es in einen allgemeinnütziges Paket, der Übersichtlichkeit wegen,  verschoben.}

			
\end{tabular}

