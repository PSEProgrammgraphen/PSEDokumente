\chapter{Änderungen am Entwurf}
\label{ch:aenderungen}

\newcounter{cnr}
\newcommand\change[2]{\textbf{\arabic{cnr}}\addtocounter{cnr}{1}. & \textbf{Aktion:} & #1 \\ & \textbf{Grund:} & #2 \\ [1ex] }
\newcommand\inlineCode[1]{{\lstinline[basicstyle=\ttfamily\color{black}]|#1|}}
\section{Gerneral}
\setcounter{cnr}{1}

\begin{tabular}{llp{0.8\linewidth}}
	\change	{Moved method getGraphBuilder from IVertexBuilder to IGraphBuilder} 
			{Better possibility to build hierarchical graphs dynamically}
	\change	{Collabsable Graph Interface hinzugefügt} 
			{unterscheiden zwischen einem compoundgraph(z.B. FieldAccess) und einem normalen zusammengeklappten subgraphen}
	\change	{JoanaBuilder Abhängigkeiten hinzugefügt} 
			{Damit jeder Builder weiß von wem er erstellt wurde und sein Produkt bei diesem platzieren kann.}
	\change	{Added AbstractPluginBase} 
			{Many functions in the concrete Plugins are nearly empty, but have to be overwritten. An AbstractPluginBase reduces identical code.}
	\change	{Removed build() functions from IGraphBuilder, IVertexBuilder, IEdgeBuilder.} 
			{build() is now only called on IGraphModelBuilder, which then calls recursively the specific build functions of the concrete classes. (Lucas)}
	\change	{Replaced nodeKind (String) field from JoanaVertex with enum. Adapted interface of JoanaVertex accordingly.} 
			{All reason why using enum is better when possibility are known at compile-time.  (Lucas)}
	\change	{Replaced edgeKind (String) field from JoanaEdge with enum. Adapted interface of JoanaEdge accordingly.} 
			{All reason why using enum is better when possibility are known at compile-time.  (Lucas)}
	\change	{SerializedGraph verschoben. Die View wird nun serialized und nicht das model} 
			{View besitzt mehr Information über den Graphen wie Koordinaten -> wichtig für SvgExporter (Jonas F)}
	\change	{Added class DefaultDirectedEdge and changed DirectedEdge from class to interface. Changed occurences of DirectedEdge to DefaultDirectedEdge in most cases in whole project.} 
			{There was a need of an interface of DirectedEdge (Jonas M)}
	\change	{Get Color in Edge und Vertex hinzugefügt} 
			{Die Farbe muss von der Edge/Vertex vorgegeben werden, damit die GUI verschiedene Farben vergeben kann, JOANA Edge und Vertex geben jeweils eine Farbe zurück die von ihrer jeweiligen KIND bestimmt wird.}
	\change	{Aktuelle LayoutOption wird in GraphView gespeichert} 
			{Um zu wissen welcher layoutalgorithmus gerade angewendet wurde un um ihm potentiell nochmals anzuwenden(Collapse/Expand, ändern der Properties...)}	
\end{tabular}
\begin{tabular}{llp{0.8\linewidth}}
	\change {Entfernen der Generischen Parameter für Vertex und Edge in Graph sowie für Vertex in Edge}
			{Zwischen den verschiedenen Hierarchie-Ebenen von Graphen und Vertex/Edge bestand eine kovariante Beziehung (z.B. Graph kann alle Typen von Vertex und Edge enthalten, DirectedGraph kann nur Typen von Vertex und DirectedEdge enthalten). Um im Allgemeinen alle Möglichkeiten zu unterstützen, musste diese Beziehungen in komplizierten und langen generischen Ausdrücken definiert werden. z.B:
\inlineCode{LayoutAlgorithm<G extends DirectedGraph<V,E>, V extends Vertex, E extends DirectedEdge<V>}. \\ & &
An vielen Stellen war die Belegung der Parameter allerdings uninteressant, weshalb oft Raw-Types als Alternative gewählt wurden, anstatt der langen, (zu) allgemeinen Parametriesierung:
\inlineCode{Graph<? extends Vertex, ? extends Edge<?>.}}

	\change {Entfernen der Vererbung JoanaGraph von DefaultDirectedGraph}
			{Als Folge der Entfernung der Generics können von DefaultDirectedGraph erbende Graphen, welche auf die Implementation der Speicherung von Edges und Vertex in DefaultDirectedGraph zurückgriefen, dies nicht ohne einen Verlust des genauen Types der Edge/Vertex weiter tun.}
	\change {\inlineCode{DefaultDirectedGraph<V,E>} und 
\inlineCode{DefaultLayering<V>} als Datenstruktur für andere Graphen}
			{Um nicht durch das Entfernen der Vererbung von DefaultDirectedGraph grundlegende Funktionen eines Graphen in jedem Graph neu implementieren zu müssen, wurde \inlineCode{DefaultDirectedGraph<V,E>} als Datenstruktur umfunktioniert welcher in einer Komposition in anderen Graphen, wie JoanaGraph und SugiyamaGraph genutzt werden kann. Gleiches gilt für DefaultLayering für das Speichern von relativen Positionen in Graphen.}
\end{tabular}

\section{Sugiyama}
\label{sec:change_sugiyama}
\setcounter{cnr}{1}

\begin{tabular}{llp{0.8\linewidth}}
	\change	{Changed method return type of reverseEdge(SugiyamaEdge edge) in ICycleRemoverGraph from Set<SugiyamaEdge> to void} 
			{Not really necessary to know which edges have been turned, it can be queried from the edge throug an instance of a SugiyamaGraph (Jonas M)}
	\change	{Added Interface ISugiyamaVertex and let SugiyamaVertex and DummyVertex implement it. Changed every occurence of SugiyamaVertex to ISugiyamaVertex in package sugiyama} 
			{It's necessary to treat SugiyamaVertex and DummyVertex the same way in a common list (Jonas M)}
	\change	{Moved class Point to from package sugiyama to package edu.kit.student.util} 
			{For a better overview (Lucas)}
	\change	{SupplementPath does not extends DirectedEdge anymore.} 
			{?}
\end{tabular}

