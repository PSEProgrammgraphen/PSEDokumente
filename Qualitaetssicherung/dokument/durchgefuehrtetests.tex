\chapter{Durchgeführte Tests}
\label{ch:durchgefuehrtetests}

\newcounter{tnr}
\newcommand\test[2]{\textbf{\arabic{tnr}}\addtocounter{tnr}{1}. & \textbf{Test:} & #1 \\ & \textbf{Aufgabe:} & #2 \\ [1ex] }

\section{Globale Testfälle aus dem Pflichtenheft}

\textbf{/T010/: }Import und Darstellung von einem JOANA Graphen\\
\textbf{Anmerkungen: }-\\

\textbf{/T020/: }Öffnen eines JOANA-Methodengraphen\\
\textbf{Anmerkungen: }-\\

\textbf{/T030/: }Selektieren mehrerer Knoten und Kanten\\
\textbf{Anmerkungen: }Da es sich während der Implementierung als wenig nützlich erwiesen hat, wurde das selektieren von Kanten nicht implementiert. Deswegen ist es in diesem Test auch nicht möglich, Kanten zu selektieren.\\
	Es werden außerdem bei mehreren ausgewählten Knoten weder eine Statistik noch eine Information zu diesen angezeigt. Lediglich von einem einzigen Knoten werden Informationen angezeigt.\\

\textbf{/T040/: }Navigation\\
\textbf{Anmerkungen: }Das Verschieben des Sichtfeldes geschieht nach der Implementierung nicht per Mittelmaus-klick halten und ziehen, sondern über Strg + Rechts-klick gedrückt halten und ziehen mit der Maus.\\

\textbf{/T050/: }Constraint zu Knoten eines geladenen Graphen hinzufügen\\
\textbf{Anmerkungen: }Durch Verschieben des Kriteriums der manuell hinzufügbaren Constraints zu Gruppen in die Wunschkriterien (siehe Pflichtenheft: 4.2 Wunschfunktionen, /FA300/ Constraints hinzufügen), wurde dies in der Implementierungsphase nicht hinzugefügt. Es ist daher hier lediglich möglich, Gruppen zu erstellen (bis einschließlich Punkt 4 des Tests).\\

\textbf{/T060/: }Filtern von Kanten\\
\textbf{Anmerkungen: }Die Menüführung zum Erreichen der Filter von Kanten ist \glqq{}Other $\to$ Edit Filter\grqq, danach klick auf Edges und dann hinzufügen eines Haken zum filtern dieser Kante, anstatt \glqq{}Editieren $\to$ Filter anpassen\grqq mit anschließendem klick auf Joana und entfernen von Haken.\\

\textbf{/T070/: }Export von einem geladenen JOANA-Graphen als SVG\\
\textbf{Anmerkungen: }Die Menüführung zum exportieren des geladenen JOANA-Graphen gechieht über \glqq{}File $\to$ Export\grqq, anstatt \glqq{}Datei $\to$ Export $\to$ SVG\grqq{}. Da nur ein Export-Format zur Auswahl steht, wurde auf den letzten Schritt der geplanten Menüführung verzichtet.\\


\section{JUnit Tests}
%alle gemachten JUnit tests. Falls welche sich mit denne aus dem Implementierungsheft überschneiden, bzw. dieselben sind, dann Verweis auf den jeweiligen Eintrag im Implementierungsheft
\subsection{Sugiyama Plugin}
\subsubsection{CycleRemover}
\setcounter{tnr}{1}
\begin{longtable}{llp{0.8\linewidth}}
	\test{testSimpleCycle()}{Erstellt einen Testgraphen aus drei Knoten die jeweils mit einem anderen Knoten über eine gerichtete Kante verbunden sind, sodass ein Kreis entsteht. Diesen übergibt es an einen \textit{SugiyamaGraph}. Dann ruft es auf dem Cycle remover \textit{removeCycles()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob der Graph azyklisch ist.}
	\test{testDoubleCycle()}{Erstellt einen Testgraphen aus vier Knoten und fünf gerichteten Kanten. Die Kanten sind so miteinander verknüpft, dass zwei Zykel entstehen. Ein kleiner Zykel drei Knoten beinhaltender und ein großer Zykel, der alle vier Knoten und damit auch den kleineren Zykel enthaltenden. Diesen übergibt es an einen \textit{SugiyamaGraph}. Dann ruft es auf dem Cycle remover \textit{removeCycles()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob der Graph azyklisch ist.}
	\test{RandomGraphsTest()}{Erstellt zwanzig zufällige, zyklische \textit{SugiyamaGraphen}. Diese bestehen beim n-ten Graphen aus aus 2n Knoten und haben eine Kantendichte von $0.95^{n}$. Dann ruft es auf dem Cycle remover \textit{removeCycles()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob der Graph azyklisch ist.}
	\test{SelfLoopTest()}{Erstellt einen Testgraphen aus einem Knoten mit einer gerichteten Kante als Selbstschleife. Diesen übergibt es an einen \textit{SugiyamaGraph}. Dann ruft es auf dem Cycle remover \textit{removeCycles()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob diese Kante umgedreht wurde.}
\end{longtable}

\subsubsection{LayerAssigner}
\setcounter{tnr}{1}
\begin{longtable}{llp{0.8\linewidth}}
	\test{assignLayers()}{Erstellt einen azyklischen Testgraphen aus fünf Knoten, welche die korrekte Ebene für die Knoten angeben. Diese werden mit fünf Kanten verbunden. Diesen übergibt es an einen \textit{SugiyamaGraph}. Dann ruft es auf dem LayerAssigner \textit{assignLayers()} mit dem \textit{SugiyamaGraph} als Parameter und testet mithilfe der Labels, ob die Knoten den richtigen Schichten zugewiesen wurden.}
	\test{LayerAssignerTest2()}{Erstellt einen azyklischen Testgraphen aus sieben Knoten, welche die korrekte Ebene für die Knoten angeben. Diese werden mit zehn Kanten verbunden. Diesen übergibt es an einen \textit{SugiyamaGraph}. Dann ruft es auf dem  LayerAssigner \textit{assignLayers()} mit dem \textit{SugiyamaGraph} als Parameter und testet mithilfe der Labels, ob die Knoten den richtigen Schichten zugewiesen wurden.}
\end{longtable}

\subsubsection{CrossMinimizer}
\setcounter{tnr}{1}
\begin{longtable}{llp{0.8\linewidth}}
	\test{singleRandomTest()}{Erstellt einen zufälligen, zyklischen, topologisch gelayerten \textit{SugiyamaGraphen}. Diese bestehen aus 20 Knoten, die jeweils 2-8 Kanten haben. Dann ruft es auf dem CrossMinimizer \textit{minimizeCrossings()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob die Anzahl der Kreuzungen verringert wurde oder zumindest gleich bleibt.}
	\test{randomTests()}{Erstellt 20 zufälligen, zyklischen, topologisch gelayerten \textit{SugiyamaGraphen}. Diese bestehen beim n-ten durchlauf aus ${n} + 10$ Knoten, die jeweils 3-4 Kanten haben. Dann ruft es auf dem CrossMinimizer \textit{minimizeCrossings()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob die Anzahl der Kreuzungen verringert wurde oder zumindest gleich bleibt.}
	\test{performanceTest()}{Erstellt 20 zufälligen, zyklischen, topologisch gelayerten \textit{SugiyamaGraphen}. Diese bestehen aus 75 Knoten, die jeweils 2-8 Kanten haben. Dann ruft es auf dem CrossMinimizer \textit{minimizeCrossings()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob die Anzahl der Kreuzungen verringert wurde oder zumindest gleich bleibt. Dabei geht es besonders um die Zeit die der Test benötigt.}
	\test{hugeTest()}{Erstellt einen zufälligen, zyklischen, topologisch gelayerten \textit{SugiyamaGraphen}. Dieser besteht aus 250 Knoten, die jeweils 2-6 Kanten haben. Dann ruft es auf dem CrossMinimizer \textit{minimizeCrossings()} mit dem \textit{SugiyamaGraph} als Parameter und testet danach ob die Anzahl der Kreuzungen verringert wurde oder zumindest gleich bleibt. Dabei geht es besonders um die Zeit die der Test benötigt.}
\end{longtable}

\subsection{SVG-Export}
\setcounter{tnr}{1}
\begin{longtable}{llp{0.8\linewidth}}
	\test{fileEndingTest()}{Testet ob der \textit{SvgExporter} die untersützten Datei Formate korrekt zurückgibt.}
	\test{exportSucessfullTest()}{Testet ob beim Exportieren eine Fehlermeldung geworfen wird.}
\end{longtable}

\section{Hallway Usability Testing}
%hier die Einträge zu den Tests mit "unwissenden" leuten. ggf. Datum des testens und commithash des verwendeten Programmes beifügen. Format der Darstellung noch offen.
Hier wird das Programm durch fachfremde Probanden, die das Programm nicht kennen, getestet.\\
Es wird ihnen erst die Funktionsweise und des Programmes erläutert, anschließend dürfen sie frei testen.\\
Alle hierbei auftretenden Auffälligkeiten, seien es mögliche Fehler oder Verbesserungsmöglichkeiten in der Bedienbarkeit, unerwünschte Nebeneffekte oder gar schwerwiegende Fehler, die das Programm abstürzen lassen, werden notiert.\\

\textbf{Proband 1: } Datum 16.08.2016, commit hash: 6b06dd0\\
\textbf{Auffälligkeiten: } Es traten keine unerwarteten Fehler im Programm auf.\\
Es wurde vor allem mit collapse gearbeitet, den Menüpunkten zm Filtern, neu importieren, exportieren wurde kaum Aufmerksamkeit geschenkt.\\
Der Proband war mit der Menüführung etwas überfordert, da es dort viele für ihn unbekannte Funktionen gab, welche er somit nur selten testete.

\textbf{Proband 2:} Datum 16.08.2016, commit hash: 6b06dd0\\
\textbf{Auffälligkeiten: } Auch hier traten keine unerwarteten Fehler im Programm auf.\\
Verwirrend war zum einen, dass man durch Doppelklick auf einen Methodengraphen in der Strukturansicht diesen öffnen kann, jedoch durch einen Doppelklick auf einen Knoten im Callgraphen diesen dazugehörigen Methodengraphen nicht öffnen konnte, nur mit "Rechtsklick->open".\\
Zum anderen war das Graph verschieben mithilfe der Tastenkombination Strg + Recktsklick ungewöhnlich.\\
Ebenso unschön wurde das Filtern von Kanten über das checken der checkboxes gefunden, sowie die Unwissenheit über momentan vorhandene Knoten und Kanten im Graphen. Man kann auch Knoten und Kanten filtern, die gar nicht im Graph vorhanden sind.\\




\section{Manuelle Tests}

\subsection{Randfalltests}
Es wurden Randfälle des Programmverlaufes getestet, die entweder zu Fehlern führen könnten oder schon zu welchen geführt haben.\\
Ausgeführt wurden Randfalltests zum Beispiel im Import, dem Layoutalgorithmus.\\
Dem Importer wurden .graphml Dateien übergeben, welche nicht einen JOANA-Graphen darstellen\\
Im Layoutalgorithmus wurden Graphen mit isolierten Knoten, Knoten auf dem selben Layer, Kanten die zumindest ein Layer überspringen und somit intern einen Pfad darstellen und Knoten mit Selbstzykel getestet. Diese Fälle müssen einzeln betrachtet werden, da davon ausgegangen wurde, dass das die Knotenstruktur auf dan Layer hierarchisch ist, also die Kanten nur von oben nach unten gehend.\\


\section{Andere durchgeführte Tests}
%hier alles wa sgetan wurde, um z.b. javadocs zu fixen, mögliche bugs mit werkzeug zu fixen, codequalität zu verbessern, etc. reinschreiben mit Beschreibung und Zweck 
\subsection{Überdeckungstests}
Es wurden Überdeckungstests sowohl über JUnit-Tests der einzelnen Projekte, als auch über alle Projekte während eines Programmlaufes mithilfe von EclEmma durchgeführt.\\
Das Programm enthält folgende Projekte, die nach Möglichkeit einzeln getestet wurden und für die es auch, falls möglich, extra JUnit Tests gibt : app, Graph von Ansicht, graphml, joana, shared, sugiyama und svg.\\
Im Projekt ''app'' befindet sich alles zu GUI gehörende, dieses Porjekt kann aufgrund der enom hohen Zahl an möglichen Interaktionen (Klick, Klick + ziehen, Rechtsklick, Graph verschieben, Knoten selektieren .....) nicht vollständig abgedeckt werden.\\
''Graph von Ansicht'' enthält sowohl Testfälle, die einzelne Projekte und Klassen testen, als auch Testfälle, die zum Testen nacheinander ablaufender Prozesse genutzt werden\\
In ''graphml'' befindet sich der GraphML-Importer.\\
''joana'' enthält JOANA-spezifische Funktionalitäten und Strukturen (z.B. Call- und Methodengraph, FieldAccess...)\\
''shared'' beinhaltet das Graphmodel und Graphbuilder-Interfaces.\\
Im Porjekt ''sugiyama'' befindet sich alles zum Layoutalgorithmus Sugiyama-Layout gehörende und notwendige(z.B. die fünf Sugiyama-Schritte, SugiyamaGraph, SugiyamaLayoutAlgorithm...)\\
''svg'' enthält den SVG-Exporter.\\
Da ''Graph von Ansicht'' nur Testfälle beinhaltet, wird auf das Anzeigen einer Überdeckung über dieses Projekt verzichtet.\\


\subsubsection{Testfälle aus dem Pflichtenheft}
Alle Testfallszenarien aus dem Pflichtenheft werden direkt nacheinander ausgeführt.\\
Die Überdeckung über alle Projekte ist sehr stark abhängig von der importierten Datei und dem benutzten Graphen dieser Datei, da diese Graphen zum Teil unterschiedliche Eigenschaften haben(selfloop, kanten auf dem selben layer...).\\

\textbf{Datei: }Fibonacci.pdg.graphml\\
\textbf{Graph: }Fibonacci.mult()\\
\textbf{Überdeckung app: }72,1\%\\
\textbf{Überdeckung graphml: }86,4\%\\
\textbf{Überdeckung joana: }80,8\%\\
\textbf{Überdeckung shared: }54,2\%\\
Es werden Parameter, die vor dem Layouten des Methodengraphen verändert werden können, durch diese Tests nicht abgedeckt.\\
\textbf{Überdeckung sugiyama: }75,2\%\\
Auch hier können keine änderbaren parameter verarbeitet werden, weil keine gesetzt wurden.\\
\textbf{Überdeckung svg: }90\%\\
\subsubsection{JUnit Tests}

\textbf{Überdeckung app: }
\textbf{Überdeckung graphml: }
\textbf{Überdeckung joana: }
\textbf{Überdeckung shared: }
\textbf{Überdeckung sugiyama: }
\textbf{Überdeckung svg: }90\%\\

\subsubsection{Test über Programmdurchlauf}

\textbf{Überdeckung app: }
\textbf{Überdeckung graphml: }
\textbf{Überdeckung joana: }
\textbf{Überdeckung shared: }
\textbf{Überdeckung sugiyama: }
\textbf{Überdeckung svg: }

\subsection{Performance Tests}
Getestet wurden hier Methodengraphen aus erstellten Graphen des JOANA-Graph-Analyzer.\\
Gemessen wird die Zeit für das Berechnen des Layout des Methodengraphen, also von der Übergabe des Methodengraphen in interner Repräsentation nach dem Import an den Layoutalgorithmus bis dieser erst einen SuguyamaGraph erstellt und anschließend die fünf Sugiyama-Steps ausgeführt hat.\\
Die benötigte Zeit zum Layouten ist nicht nur abhängig von der Anzahl der Knoten und Kanten eines Graphen, sondern auch von dessen Aufbau (Anzahl an logischen Layern, einzelne dichte Stellen im Graphen, ...).\\
Ebenso hängt die benötigte Zeit stark von der Anzahl der Läufe des Kreuzungsminimierers bei der Kreuzungsminimierung zwischen zwei Layern ab. Die Anzahl an Läufen kann über den Menüpunkt \glqq{}Layout $\to$ Properties\grqq angepasst werden.\\
Im folgenden werden Graphen mit einer Anzahl von 10 Läufen gelayouted.\\

\textbf{Datei: }BigControl.pdg.graphml\\
\textbf{Methodengraph: }BigControl.main()\\
\textbf{Information zum Graph: }779 Knoten, 4917 Kanten, 1 FieldAccess\\
\textbf{Programmeinstellungen: }CrossMinimizer runs: 10, use threshold: false\\
\textbf{Zeit: }6.6s, 162.4s, 30.5s, 8.9s, 6.6s, 7.6s, 369.1s, 6.9s \\

\textbf{Datei: }PhiMadness.pdg.graphml\\
\textbf{Methodengraph: }PhiMadness.phiMadness()\\
\textbf{Information zum Graph: }393 Knoten, 2937 Kanten, 25 FieldAccesses\\
\textbf{Programmeinstellungen: }CrossMinimizer runs: 10, use threshold: false\\
\textbf{Zeit: }44.5s, 79.6s, 46.6s, 58.3s, 51.7s, 38.3s, 43.4s, 45.1s\\

%Hier Satz, warum Zeiten so extrem abweichen können, auch mit constraints und fieldaccesses argumentieren!



%\textbf{Datei: }
%\textbf{Methodengraph: }
%\textbf{Information zum Graph: }
%\textbf{Programmeinstellungen: }
%\textbf{Zeit: }