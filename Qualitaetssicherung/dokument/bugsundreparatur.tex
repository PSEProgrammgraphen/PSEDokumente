\chapter{Bugs und Reparatur}
\label{ch:bugsundreparatur}

\newcounter{cnr}
\newcommand{\bug}[4]{\textbf{\##1} & \textbf{Fehlersymptom:} & #2 \\ & \textbf{Fehlergrund:} & #3 \\ & \textbf{Fehlerbehebung:} & #4 \\ [1ex] }


\begin{longtable}{llp{0.8\linewidth}}
\bug{1}
       {Graphische Hervorhebung von FieldAccessen durch eine farbige Box im Hintergrund wird nicht angezeigt.}
       {Die Struktur im Hintergrund war leicht fehlerhaft und in der Erstellung der Box gab es einen Bug.}
       {Die Struktur im Hintergrund wurde refactored und der Bug beim erstellen des Hintergrunds wurde behoben.}
\bug{2}
       {Einige Kanten werden übereinanderliegend gezeichnet.}
       {Dummy Vertices werden übereinander platziert, da zum einen der Code zum überprüfen von Überlagerung von Kanten fehlerhaft ist und da die Kanten die mehrere Ebenen überdecken nicht immer genügend verschoben werden. Außerdem gibt es Mehrfachzuweisungen von Knoten zu zu begradigenden Abschnitten.}
       {Die fehlerhafte Code zur Überprüfung von Kantenschnitten im Vertex Positioner wurde korrigiert, indem ein fehlerhafter Vergleich berichtigt wurde. Er kann nun auch mit 1 breiten Kanten arbeiten. Die Verschiebung der Kanten wird nun so oft ausgeführt, bis sich Kanten nicht mehr überdecken. Es wurde außerdem ein schwerwiegender Fehler der zu der Mehrfachzuweisung führte behoben. Hier hat ein rekursiver Teilalgorithmus ergebnisse verdoppelt.}
\bug{7}
       {Kanten, welche keine Ebene überspannen werden nie begradigt}
       {Diese Kanten werden beim suchen nach Segmenten(Kantenketten, die im VertexPositioner später begradigt werden) nicht beachtet}
       {Diese Kanten werden nun beim starten des VertexPositioner ebenfalls hinzugefügt. Im Zuge dieser Korrektur wurde es außerdem ermöglicht die Endknoten von Kanten, welche eine oder mehr Ebenen überspringen, zu den aus ihnen enstehenden Segmenten hinzuzufügen.}
\bug{8}
	   {Kollabierte Knoten in einem FieldAccessGraph verschwinden bei Ihrer Erstellung.}
	   {Bei dem Layouten von MethodGraphen wurden alle FieldAccess betrachtet. Auch FAs die teilweise kollabiert wurden.}
	   {Es werden nun nur noch FAs welche vollständig ausgeklappt sind im MethodGraphLayout betrachtet}
\bug{9}
       {Beim Öffnen eines Graphens über die Kommandozeile wurde nicht das Default Layout des ausgewählten Workspace übernommen.}
       {Es wurde immer der LayoutSelectionDialog aufgerufen, obwohl ein workspace angegeben wurde.}
       {Aufruf gelöscht und das Default Layout aus dem Workspace angewendet.}

\bug{10}
       {Keine Informationen oder Warnung über falsch eingegebene Kommandozeilenparameter.}
       {Keine explizite Überprüfung der Eingaben. Es wurde angenommen, dass der User alle Eingaben richtig macht.}
       {Hinzufügen von expliziten Überprüfungen und Anzeigen von Fehlermeldungen mit hilfreicher Information.}
       
\bug{11}
       {Falls das Joana-Workspace für eine generische GraphML-Datei ausgewählt wird, kommt keine Warnung und es passiert nichts.}
       {Keine Überprüfung ob ein GraphBuilder für diesen Graphentyp existiert.}
       {Überprüfung ob GraphBuilder null ist.}
\bug{12}
       {Der Graph springt beim verschieben mit der Maus zu Beginn ein Stück nach unten.}
       {Die Berechnung der Mausposition wurde die Position im Fenster genutzt.}
       {Nutzen der Mausposition des Mausevents die das Ziehen einleitet.}
\bug{13}
       {Es gibt keine Option zur Einstellung ob eine Abbruchgrenze beim Kreuzungsminimieren in Abhängigkeit von den vorhandenen Kreuzungen gewählt werden soll.}
       {Diese Option wird in den CrossMinimizer Einstellungen nicht bereitgestellt}
       {Die Option wurde als Checkbox hinzugefügt und wird während der Kreuzungsminimierung beachtet.}
\bug{17}
	   {Das Filtern von Knoten bestimmten Types (z.B. EXPR) in MethodGraphLayout führt zu einer NullPointerException}
	   {Für das Layouten der FAs und des ganzen MethodGraphen wurde der selbe Layoutalgorithmus, mit den selben Constraints gewählt.}
	   {Separate Instanzen des SugiyamaAlgorithm für FAs und MethodGraph.}
\bug{22}
       {Die alte StrukturView kann nach Import einer neuen Datei nicht zurückgebracht werden.}
       {Alte Graphen wurden nach einem neuen Import nicht geschlossen, obwohl die Anwendung nur eine einzelne Datei unterstützt.}
       {Bereits offene Graphen werden nach erfolgreichem Import geschlossen.}
\bug{23}
       {Ähnlich wie in Bug 22 wird versucht nach einem Import über den noch offenen alten Callgraphen einen Methodengraphen zu öffnen.}
       {Siehe Bug 22}
       {Siehe Bug 22}
\bug{24}
       {Programm stürzt ab, falls der eingegebene Dateipfad über den Kommandozeilenparameter --in keinen Punkt enthält.}
       {Falls Dateipfad keinen Punkt erhält gibt Java Methode lastIndexOf('.') als Ergebnis -1 zurück. Dieses Ergebniss wird bei substring() als ungültiger Index verwendet was zum Abstürz führt.}
       {Vor Aufruf der Methode substring() wird überprüft ob der Dateipfad einen Punkt enthält. Falls nicht wird eine Fehlermeldung ausgegeben.}
\bug{25}
       {Es wird ein Fehler geworfen, wenn man die ENTR Knoten filtert.}
       {Der VertexPositioner benötigt mindestens ein Vertex pro Graph.}
       {Der VertexPositioner überprüft nun am Anfang, ob der Graph leer ist und läuft in diesem Fall nicht durch.}       
\bug{27}
       {Text in exportierter SVG-Datei ist größer als die Textboxen der Knoten.}
       {Default Textgröße in SVG ist größer als Default Textgröße innerhalb der GUI. Die Größe der Textboxen richten sich jedoch nach der Textgröße der GUI.}
       {Hinzufügen einer expliziten Textgröße zur SVG-Datei, welche der Textgröße der GUI entspricht.}
		
\bug{28}
		{Kanten laufen ggf. aus der Box des Feldzugriffes hinaus.}
		{Kantenläufe wurden bei der Berechnung der Größe der Box nicht berücksichtigt.}
		{Kantenläufe werden nun bei der Berechnung der Größe der Box berücksichtigt.}
		
\bug{30}
		{Kanten laufen durch Knoten durch und manchmal von unten rein und verbinden sich dann oben auf dem Knoten.}
		{Der Kantenzeichner ging davon aus, dass Kanten immer von oben nach unten verlaufen, also der source-Knoten sich immer oberhalb des target-Knoten befindet. Durch relative- und absolute-layer-constraints kann es aber vorkommen, dass miteinander verbundene Knoten auf dem selben layer liegen, weswegen die Kanten teilweise unvorhersehbar durch Knoten gezeichnet wurden.}
		{Kanten zwischen Knoten auf dem selben layer werden nun gesondert gezeichnet, und zwar unterhalb des layers.}
\bug{31}
        {Beim Zoomen wird nicht vom Mauszeiger weg oder zum Mauszeiger hin gezoomt. Der Fokus und Sichtbereich springt herum.}
        {Die GraphView wurde durch das Zoomen vergrößert, dadurch gab es von den äußeren Oberflächenelementen, die um die GraphView gelegt waren, Interferenzen, die das Springen und unfokussierte Zoomen ausgelöst haben.}
        {Die Ansicht des Graphen besteht nun aus 4 ineinander verschachtelten Panes, wobei das innerste die GraphView und das äußerste ein ScrollPane ist. Vergrößert wird beim Zoomen nun das Pane welches direkt um der GraphView liegt. Das Pane darum passt sich per Listener immer an die Größe der beiden inneren Panes an. Dadurch entstehen keinen Interferenzen mehr und anderes ungewolltes Verhalten tritt auch nicht mehr auf.}
        
\bug{40}
        {Die Richtung mancher Kanten zwischen zwei Knoten änderte sich manchmal nach neuem importieren oder neuem layouten des Graphen.}
        {Im Sugiyama werden notwendigerweise zuallererst Kanten gedreht, die Zykel im Graph verursachen. Der Kantenzeichner im letzten Schritt des Sugiyama hat nun nur die gedrehten Kanten, die sich über ein layer erstrecken in ihrer Richtung angepasst. Kanten, die über mehrere layer gingen wurden ignoriert, da diese in einem anderen Set lagen.}
        {Der Kantenzeichner passt nun durch Berücksichtigung des Sets der sich über mehrere Layer erstreckenden Kanten, von diesen ehemals gedrehte Kanten in ihrer Richtung an.}

\bug{45}
	{FieldAccess Boxen werden in der exportierten SVG-Datei nicht angezeigt.}
	{Die FieldAccess Boxen werden nicht zum serialisierten Graphen hinzugefügt.}
	{Die FieldAccess Boxen werden nun als zusätzliche Knoten im serialisierten Graphen gespeichert.}
		
%		\bug{}
%		{}
%		{}
%		{}
\end{longtable}